<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="千里之行,始于足下">
<meta property="og:type" content="website">
<meta property="og:title" content="娜一隅">
<meta property="og:url" content="http://acmwln.github.io.com/index.html">
<meta property="og:site_name" content="娜一隅">
<meta property="og:description" content="千里之行,始于足下">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="娜一隅">
<meta name="twitter:description" content="千里之行,始于足下">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://acmwln.github.io.com/">





  <title>娜一隅</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">娜一隅</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://acmwln.github.io.com/2020/03/28/性能优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="遗忘的一隅">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="娜一隅">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/28/性能优化/" itemprop="url">性能优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-28T16:52:30+08:00">
                2020-03-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>这篇文章用来总结前端的一些性能优化点</p>
<h2 id="网络篇"><a href="#网络篇" class="headerlink" title="网络篇"></a>网络篇</h2><h3 id="一-http"><a href="#一-http" class="headerlink" title="一. http"></a>一. http</h3><h4 id="1-减少HTTP请求次数和请求资源大小"><a href="#1-减少HTTP请求次数和请求资源大小" class="headerlink" title="1.  减少HTTP请求次数和请求资源大小"></a>1.  减少HTTP请求次数和请求资源大小</h4><ul>
<li><p>资源合并压缩</p>
</li>
<li><p>字体图标</p>
</li>
<li><p>Base64</p>
</li>
<li><p>GZIP（一般的文件能压缩60%多）</p>
</li>
<li><p>图片懒加载<br>比如：图片较多的情况下采用懒加载，首先将页面上的图片的 src 属性设为空字符串，而图片的真实路径则设置在data-original属性中，当页面滚动的时候需要去监听scroll事件，在scroll事件的回调中，判断我们的懒加载的图片是否进入可视区域,如果图片在可视区内将图片的 src 属性设置为data-original 的值，这样就可以实现延迟加载。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;img src=<span class="string">""</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"image-item"</span> lazyload=<span class="string">"true"</span> data-original=<span class="string">"https://images4.c-ctrip.com/target/200t160000010oeje3CF7_R_900_504.jpg"</span>/&gt;</span><br><span class="line">&lt;img src=<span class="string">""</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"image-item"</span> lazyload=<span class="string">"true"</span> data-original=<span class="string">"https://images4.c-ctrip.com/target/200q160000010rida8F51_R_750_400.jpg"</span>/&gt;</span><br><span class="line">&lt;img src=<span class="string">""</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"image-item"</span> lazyload=<span class="string">"true"</span> data-original=<span class="string">"https://images4.c-ctrip.com/target/200s160000010x38q9DB4_R_750_400.jpg"</span>/&gt;</span><br><span class="line">&lt;img src=<span class="string">""</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"image-item"</span> lazyload=<span class="string">"true"</span> data-original=<span class="string">"https://images4.c-ctrip.com/target/2009160000010smcl0C45_R_750_400.jpg"</span>/&gt;</span><br><span class="line">&lt;img src=<span class="string">""</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"image-item"</span> lazyload=<span class="string">"true"</span> data-original=<span class="string">"https://images4.c-ctrip.com/target/200e1e000001ey31h2478_R_130_130.jpg"</span>/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> viewHeight = <span class="built_in">document</span>.documentElement.clientHeight;<span class="comment">//获取可视区域的高度</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyload</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> eles=<span class="built_in">document</span>.querySelectorAll(<span class="string">'img[data-original][lazyload]'</span>)   </span><br><span class="line">	  <span class="built_in">Array</span>.prototype.forEach.call(eles,<span class="function"><span class="keyword">function</span>(<span class="params">item,index</span>)</span>&#123;</span><br><span class="line">           <span class="keyword">var</span> rect;</span><br><span class="line">           <span class="keyword">if</span>(item.dataset.original===<span class="string">""</span>) <span class="keyword">return</span></span><br><span class="line">		rect=item.getBoundingClientRect() </span><br><span class="line">		     <span class="comment">//用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置</span></span><br><span class="line">			<span class="keyword">if</span>(rect.bottom&gt;=<span class="number">0</span> &amp;&amp; rect.top &lt; viewHeight)&#123;</span><br><span class="line">			(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				<span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">				img.src=item.dataset.original;</span><br><span class="line">				img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">					item.src = img.src</span><br><span class="line">				&#125;</span><br><span class="line">				item.removeAttribute(<span class="string">"data-original"</span>)   <span class="comment">//移除属性，下次不再遍历</span></span><br><span class="line">				item.removeAttribute(<span class="string">"lazyload"</span>)</span><br><span class="line">			&#125;)()</span><br><span class="line">		&#125;</span><br><span class="line">	 &#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	lazyload();<span class="comment">//刚开始还没滚动屏幕时，要先触发一次函数，初始化首页的页面图片</span></span><br><span class="line">	 <span class="built_in">document</span>.addEventListener(<span class="string">"scroll"</span>,lazyload)</span><br></pre></td></tr></table></figure>
</li>
<li><p>预加载<br>预加载简单来说就是将所有所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。</p>
</li>
<li><p>数据延迟分批加载</p>
</li>
<li><p>CDN资源</p>
<ul>
<li><p>CDN的核心功能</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">缓存  “缓存”就是说我们把资源 copy 一份到 CDN 服务器上这个过程</span><br><span class="line">回源  CDN 发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者它的上层服务器）去要这个资源的过程。</span><br></pre></td></tr></table></figure>
</li>
<li><p>CDN用来存放静态资源</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对变化比较少的资源配置超长时间的本地缓存   --- 节省带宽</span><br><span class="line">对资源采用内容摘要作为缓存更新依据 --- 精确的缓存控制静态资源</span><br><span class="line">静态资源实现CDN部署  ---优化网络请求</span><br><span class="line">更新资源发布路径实现非覆盖式发布  —— 平滑升级</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="二-图片优化"><a href="#二-图片优化" class="headerlink" title="二.图片优化"></a>二.图片优化</h3><h4 id="不同业务场景下的图片方案选型"><a href="#不同业务场景下的图片方案选型" class="headerlink" title="不同业务场景下的图片方案选型"></a>不同业务场景下的图片方案选型</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JPEG/JPG-有损压缩、体积小、加载快、不支持透明</span><br><span class="line">png - 无损压缩、质量高、体积大、支持透明</span><br><span class="line">SVG - 文本文件、体积小、不失真、兼容性好</span><br><span class="line">Base64 - 文本文件、依赖编码、小图标解决方案</span><br><span class="line">WebP - 是 Google 专为 Web 开发的一种旨在加快图片加载速度的图片格式，它支持有损压缩和无损压缩。兼容性不好</span><br></pre></td></tr></table></figure>

<h2 id="渲染篇"><a href="#渲染篇" class="headerlink" title="渲染篇"></a>渲染篇</h2><h4 id="1-浏览器渲染"><a href="#1-浏览器渲染" class="headerlink" title="1. 浏览器渲染"></a>1. 浏览器渲染</h4><ul>
<li><p>标签语义化和避免深层次嵌套</p>
</li>
<li><p>CSS选择器渲染是从右到左</p>
<ul>
<li>避免使用通配符，只对需要用到的元素进行选择</li>
<li>关注可以通过继承实现的属性，避免重复匹配重复定义。</li>
<li>少用标签选择器。如果可以，用类选择器替代</li>
<li>减少嵌套，尽可能扁平化。后代选择器的开销是最高的，因此我们应该尽量将选择器的深度降到最低（最高不要超过三层），尽可能使用类来关联每一个标签元素</li>
</ul>
</li>
<li><p>尽早尽快地把CSS下载到客户端（充分利用HTTP多请求并发机制）</p>
<ul>
<li>style  针对内联样式不多的情况下可以使用，和html一起解析</li>
<li>link   异步的请求下载css</li>
<li>@import  同步的请求下载css</li>
<li>放到顶部</li>
</ul>
</li>
<li><p>避免阻塞的JS加载</p>
<ul>
<li>放到底部</li>
</ul>
</li>
<li><p>减少DOM的回流和重绘<br>  避免DOM回流</p>
<ul>
<li><p>放弃传统操作DOM的时代，基于react/vue开始数据影响视图模式</p>
</li>
<li><p>分离读写操作（现在的浏览器都有渲染队列的机制）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">offsetTop,offsetLeft,offsetWidth,offsetHeight,clientTop,clientLeft,</span><br><span class="line">clientWidth,clientHeight,scrollTop,scrollLeft,scrollWidth,scrollHeight,getComputedStyle,currentStyle....会刷新渲染队列</span><br></pre></td></tr></table></figure>
</li>
<li><p>样式集中改变</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.style.cssText = <span class="string">'width:20px;height:20px;'</span></span><br><span class="line">div.className=<span class="string">'box'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>缓存布局信息</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div.style.left = div.offsetLeft+<span class="number">1</span>+<span class="string">'px'</span></span><br><span class="line">div style.top = div.offsetTop+<span class="number">1</span>+<span class="string">'px'</span></span><br><span class="line">改为</span><br><span class="line"><span class="keyword">var</span> curLeft = div.offsetLeft;</span><br><span class="line"><span class="keyword">var</span> curTop = div.offsetTop;</span><br><span class="line">div.style.left = curLeft+<span class="number">1</span>+<span class="string">'px'</span></span><br><span class="line">div.style.top = curTop+<span class="number">1</span>+<span class="string">'px'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>元素批量修改</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文档碎片：createDocumentFragment</span><br><span class="line">模板字符串拼接</span><br></pre></td></tr></table></figure>
</li>
<li><p>动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上（脱离文档流）</p>
</li>
<li><p><code>CSS3</code>硬件加速（<code>GPU</code>加速）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比起考虑如何减少回流和重绘，我们更期望的是，根本不要回流重绘；transform/opacity/filters...这些属性会触发硬件加速，不会引发回流和重绘...</span><br><span class="line">可能会引发的坑：过多使用会占用大量内存性能，消耗严重，有时候会导致字体模糊等。</span><br></pre></td></tr></table></figure>
</li>
<li><p>牺牲平滑度换取速度<br>每次1像素移动一个动画，但是如果此动画使用了100%的CPU，动画就会看上去是跳动的，因为浏览器正在与更新回流作斗争。每次移动3像素可能看起来平滑度低了，但它不会导致CPU在较慢的机器中抖动。</p>
</li>
<li><p>避免table布局和使用css的javascript表达式</p>
</li>
<li><p>有图片的地方采用占位图，防止下载下来的图片导致页面结构发生变化，引起不必要的回流。</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-服务端渲染"><a href="#2-服务端渲染" class="headerlink" title="2. 服务端渲染"></a>2. 服务端渲染</h4><p>为了响应快，用户体验好，首屏渲染快，利于SEO，使用了服务端渲染。</p>
<h4 id="3-事件的节流与防抖"><a href="#3-事件的节流与防抖" class="headerlink" title="3. 事件的节流与防抖"></a>3. 事件的节流与防抖</h4><h4 id="4-加载动画"><a href="#4-加载动画" class="headerlink" title="4.加载动画"></a>4.加载动画</h4><p>对页面上的一些连续的动画，采用requestAnimationFrame或者InteractionManager实现，前者是浏览器按照60/s的频率控制ui刷新，实现流畅的效果，而不再需要开发人员烦心刷新频率的问题了。后者是将一些耗时较长的工作安排到所有互动或动画完成之后再进行。这样可以保证JavaScript动画的流畅运行。<br><a href="https://www.jianshu.com/p/4c1d96132756" target="_blank" rel="noopener">参考</a></p>
<h2 id="应用缓存"><a href="#应用缓存" class="headerlink" title="应用缓存"></a>应用缓存</h2><h4 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h4><ul>
<li><code>Service Worker</code>：浏览器独立线程进行缓存</li>
<li><code>Memory Cache</code> : 内存缓存</li>
<li><code>Disk Cache</code>：硬盘缓存</li>
<li><code>Push Cache</code>：推送缓存（<code>HTTP/2</code>中的）</li>
</ul>
<p>打开网页，地址栏输入地址： 查找 <code>disk cache</code> 中是否有匹配，如有则使用，如没有则发送网络请求。<br>普通刷新 (<code>F5</code>)：因为 TAB 并没有关闭，因此 <code>memory cache</code> 是可用的，会被优先使用(如果匹配的话)，其次才是 <code>disk cache</code>。<br>强制刷新 (<code>Ctrl + F5</code>)：浏览器不使用缓存，因此发送的请求头部均带有 <code>Cache-control: no-cache</code>(为了兼容，还带了 <code>Pragma: no-cache</code>)，服务器直接返回 <code>200</code> 和最新内容。<br>接着涉及到浏览器强缓存和协商缓存，自行了解</p>
<ul>
<li>数据缓存：<code>LocalStorage</code>本地存储</li>
</ul>
<h2 id="RN方面"><a href="#RN方面" class="headerlink" title="RN方面"></a>RN方面</h2><ol>
<li><p><code>RN</code>中在渲染城市列表页这种长列表时候，使用<code>FlatList</code>代替<code>ScrollView</code>,<code>ListView</code>，缓解页面的卡顿。他们的区别是<code>ScrollView</code>只会<code>render</code>一次，当数据量很大的情况下很卡；<br><code>ListView</code>基于一个数据源，对数据源中的每一项数据调用<code>renderRow</code>进行<code>render</code>。并且不会一次性<code>render</code>所有数据，而是首先<code>render</code>屏幕上能看到的数据（假实现），<code>Listview</code>就是在<code>scrollView</code>里面不断添加<code>row</code>，但<code>row</code>移出可见范围之外后依然还在<code>scrollview</code>里面；<code>FlatList</code>，是在<code>Listview</code>继续优化的，用户看不到的 <code>items</code>，就用空白代替，这样既节约内存，渲染又快。缺点就是，用户可能滚动太快，空白还没被渲染成真的 <code>items</code>，就被看见了。</p>
</li>
<li><p><code>rn</code>中的查询提前加载资源页的<code>webview</code></p>
</li>
<li><p>动画与操作性能中的路由切换掉帧，使用了 <code>InteractionManager.runAfterInteractions</code></p>
</li>
</ol>
<h2 id="业务层面-BFF"><a href="#业务层面-BFF" class="headerlink" title="业务层面(BFF)"></a>业务层面(BFF)</h2><p>  <code>bff（GraphQL+koa）</code>，随着多终端、多平台、多业务形态、多技术选型等各方面的发展，前后端的数据交互，日益复杂，同一份数据，可能以多种不同的形态和结构，在多种场景下被消费，理想情况下这部分是由后端解决，然而，不知是因为后端的领域模型，作为前端，我们感受到的是，后端提供的接口，越发不够前端友好。我们必须自行组合多个后端接口，才能获取到完整的数据结构。</p>
<h2 id="工程化方面-webpack"><a href="#工程化方面-webpack" class="headerlink" title="工程化方面(webpack)"></a>工程化方面(webpack)</h2><ol>
<li>增加资源 <code>happypack</code></li>
<li>缩小打包作用域  <code>dll</code>动态链接库</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://acmwln.github.io.com/2020/03/22/React新特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="遗忘的一隅">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="娜一隅">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/22/React新特性/" itemprop="url">精读React新特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-22T14:54:07+08:00">
                2020-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>于 2017.09.26 Facebook 发布 React v16.0 版本，时至今日已更新到 React v16.6，且引入了大量的令人振奋的新特性，本文章将带领大家根据 React 更新的时间脉络了解 React16 的新特性。<br>按照 React16 的更新时间，从 React v16.0 ~ React v16.6 进行概述。</p>
<h2 id="React-v16-0"><a href="#React-v16-0" class="headerlink" title="React v16.0"></a>React v16.0</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render 支持返回数组和字符串、Error Boundaries、createPortal、支持自定义 DOM 属性、减少文件体积、fiber；</span><br></pre></td></tr></table></figure>

<h2 id="React-v16-1"><a href="#React-v16-1" class="headerlink" title="React v16.1"></a>React v16.1</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-call-return；</span><br></pre></td></tr></table></figure>

<h2 id="React-v16-2"><a href="#React-v16-2" class="headerlink" title="React v16.2"></a>React v16.2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fragment；</span><br></pre></td></tr></table></figure>

<h2 id="React-v16-3"><a href="#React-v16-3" class="headerlink" title="React v16.3"></a>React v16.3</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createContext、createRef、forwardRef、生命周期函数的更新、Strict Mode；</span><br></pre></td></tr></table></figure>

<h2 id="React-v16-4"><a href="#React-v16-4" class="headerlink" title="React v16.4"></a>React v16.4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pointer Events、update getDerivedStateFromProps；</span><br></pre></td></tr></table></figure>

<h2 id="React-v16-5"><a href="#React-v16-5" class="headerlink" title="React v16.5"></a>React v16.5</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Profiler；</span><br></pre></td></tr></table></figure>

<h2 id="React-v16-6"><a href="#React-v16-6" class="headerlink" title="React v16.6"></a>React v16.6</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memo、lazy、Suspense、static contextType、static getDerivedStateFromError()；</span><br></pre></td></tr></table></figure>

<h2 id="React-v16-7（-Q1-2019）"><a href="#React-v16-7（-Q1-2019）" class="headerlink" title="React v16.7（~Q1 2019）"></a>React v16.7（~Q1 2019）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hooks；</span><br></pre></td></tr></table></figure>

<h2 id="React-v16-8（-Q2-2019）"><a href="#React-v16-8（-Q2-2019）" class="headerlink" title="React v16.8（~Q2 2019）"></a>React v16.8（~Q2 2019）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Concurrent Rendering；</span><br></pre></td></tr></table></figure>

<h2 id="React-v16-9（-mid-2019）"><a href="#React-v16-9（-mid-2019）" class="headerlink" title="React v16.9（~mid 2019）"></a>React v16.9（~mid 2019）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Suspense <span class="keyword">for</span> Data Fetching；</span><br></pre></td></tr></table></figure>

<h2 id="新的生命周期"><a href="#新的生命周期" class="headerlink" title="新的生命周期"></a>新的生命周期</h2><h3 id="Mounting（加载阶段：涉及4个钩子函数）"><a href="#Mounting（加载阶段：涉及4个钩子函数）" class="headerlink" title="Mounting（加载阶段：涉及4个钩子函数）"></a>Mounting（加载阶段：涉及4个钩子函数）</h3><h6 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor()"></a>constructor()</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加载的时候调用一次，可以初始化state</span><br></pre></td></tr></table></figure>

<h6 id="static-getDerivedStateFromProps-props-state"><a href="#static-getDerivedStateFromProps-props-state" class="headerlink" title="static getDerivedStateFromProps(props, state)"></a>static getDerivedStateFromProps(props, state)</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">组件每次被rerender的时候，包括在组件构建之后</span><br><span class="line">(虚拟dom之后，实际dom挂载之前)，每次获取新的props或state之后；</span><br><span class="line">每次接收新的props之后都会返回一个对象作为</span><br><span class="line">新的state，返回null则说明不需要更新state；配合componentDidUpdate，</span><br><span class="line">可以覆盖componentWillReceiveProps的所有用法</span><br></pre></td></tr></table></figure>

<p><code>getDerivedStateFromProps(nextProps, prevState)</code> 其作用是根据传递的 <code>props</code> 来更新 <code>state</code>。它的一大特点是无副作用，由于处在 <code>Render Phase</code> 阶段，所以在每次的更新都会触发该函数， 在 API 设计上采用了静态方法，使其无法访问实例、无法通过 <code>ref</code> 访问到 <code>DOM</code> 对象等，保证了该函数的纯粹高效。</p>
<p>为了配合未来的 <code>React</code> 异步渲染机制，<code>React v16.4</code> 对 <code>getDerivedStateFromProps</code> 做了一些改变， 使其不仅在 <code>props</code> 更新时会被调用，<code>setState</code> 时也会被触发。</p>
<ul>
<li>如果改变 <code>props</code> 的同时，有副作用的产生，这时应该使用 <code>componentDidUpdate</code>；</li>
<li>如果想要根据 <code>props</code> 计算属性，应该考虑将结果 <code>memoization</code> 化；</li>
<li>如果想要根据 <code>props</code> 变化来重置某些状态，应该考虑使用 受控组件；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> getDerivedStateFromProps(props, state) &#123;</span><br><span class="line">  <span class="keyword">if</span> (props.value !== state.controlledValue) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      controlledValue: props.value,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行</span><br></pre></td></tr></table></figure>

<h6 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a>componentDidMount()</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组件渲染之后调用，只调用一次</span><br></pre></td></tr></table></figure>

<h3 id="Updating（更新阶段：涉及5个钩子函数"><a href="#Updating（更新阶段：涉及5个钩子函数" class="headerlink" title="Updating（更新阶段：涉及5个钩子函数)"></a>Updating（更新阶段：涉及5个钩子函数)</h3><h6 id="static-getDerivedStateFromProps-props-state-1"><a href="#static-getDerivedStateFromProps-props-state-1" class="headerlink" title="static getDerivedStateFromProps(props, state)"></a>static getDerivedStateFromProps(props, state)</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">组件每次被rerender的时候，包括在组件构建之后</span><br><span class="line">(虚拟dom之后，实际dom挂载之前)，每次获取新的props或state之后；</span><br><span class="line">每次接收新的props之后都会返回一个对象</span><br><span class="line">作为新的state，返回null则说明不需要更新state；配合componentDidUpdate，</span><br><span class="line">可以覆盖componentWillReceiveProps的所有用法</span><br></pre></td></tr></table></figure>

<h6 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps, nextState)"></a>shouldComponentUpdate(nextProps, nextState)</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">组件接收到新的props或者state时调用，</span><br><span class="line"><span class="built_in">return</span> <span class="literal">true</span>就会更新dom（使用diff算法更新），</span><br><span class="line"><span class="built_in">return</span> <span class="literal">false</span>能阻止更新（不调用render）</span><br></pre></td></tr></table></figure>

<h6 id="render-1"><a href="#render-1" class="headerlink" title="render()"></a>render()</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行</span><br></pre></td></tr></table></figure>

<h6 id="getSnapshotBeforeUpdate-prevProps-prevState"><a href="#getSnapshotBeforeUpdate-prevProps-prevState" class="headerlink" title="getSnapshotBeforeUpdate(prevProps, prevState)"></a>getSnapshotBeforeUpdate(prevProps, prevState)</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">触发时间: 会在组件更新之前获取一个snapshot</span><br><span class="line">（update发生的时候，在render之后，在组件dom渲染之前），</span><br><span class="line">并可以将计算得到的值或从DOM得到的信息传递到</span><br><span class="line">componentDidUpdate(prevProps,prevState,snapshot)函数的第三个参数，</span><br><span class="line">配合componentDidUpdate, 可以覆盖componentWillUpdate的所有用法，</span><br><span class="line">常用于scroll位置定位等场景。</span><br></pre></td></tr></table></figure>

<h6 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate()"></a>componentDidUpdate()</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组件加载时不调用，组件更新完成后调用</span><br></pre></td></tr></table></figure>

<h3 id="Unmounting（卸载阶段：涉及1个钩子函数）"><a href="#Unmounting（卸载阶段：涉及1个钩子函数）" class="headerlink" title="Unmounting（卸载阶段：涉及1个钩子函数）"></a>Unmounting（卸载阶段：涉及1个钩子函数）</h3><h6 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组件渲染之后调用，只调用一次</span><br></pre></td></tr></table></figure>

<h3 id="Error-Handling-错误处理"><a href="#Error-Handling-错误处理" class="headerlink" title="Error Handling(错误处理)"></a>Error Handling(错误处理)</h3><h6 id="componentDidCatch-error，info"><a href="#componentDidCatch-error，info" class="headerlink" title="componentDidCatch(error，info)"></a>componentDidCatch(error，info)</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">任何一处的javascript报错会触发</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://acmwln.github.io.com/2020/03/17/interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="遗忘的一隅">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="娜一隅">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/17/interview/" itemprop="url">常见面试题总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-17T11:57:40+08:00">
                2020-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>最近面了很多公司，整理一波常考的知识点</p>
<h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>http相关没有特别难的，常见的了解下就没问题。</p>
<ol>
<li><p>介绍Http2，优点和存在什么坑或问题（必考）</p>
</li>
<li><p>HTTP报文的请求和返回会有几个部分（请求行、请求头、请求体）；每部分具体都有什么（常见的请求头）</p>
</li>
<li><p>GET和POST的区别</p>
</li>
<li><p>输入url到页面加载全过程（必考）</p>
</li>
<li><p>介绍HTTPS；HTTP和HTTPS的区别（必考）</p>
</li>
<li><p>HTTPS加密过程</p>
</li>
<li><p>HTTP缓存控制（强缓存、弱缓存）；缓存相关的HTTP请求头（必考）</p>
</li>
<li><p>对跨域的了解，跨域怎么解决（必考）</p>
</li>
<li><p>cors的返回头、cors预请求，什么时候会出发预请求（必考）</p>
</li>
<li><p>tcp的长连接和http2多路复用相关</p>
</li>
<li><p>tcp拥塞控制和流量控制</p>
</li>
<li><p>三次握手四次挥手，为什么三次和四次</p>
</li>
<li><p>前端性能优化（必考）</p>
</li>
</ol>
<h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><p>css最近问的越来越少了，只要会写常见的布局就ok，难点的答不出来也没事。相比移动端相关的会问题的比较多。</p>
<ol>
<li>盒模型</li>
<li>positon的值，都是根据什么定位（注意下还有sticky）</li>
<li>栅格布局的原理</li>
<li>垂直居中布局</li>
<li>上中下布局，中间自适应</li>
<li>左中右布局，中间自适应</li>
<li>什么css可以减少重绘</li>
</ol>
<h3 id="8-动画相关属性"><a href="#8-动画相关属性" class="headerlink" title="8. 动画相关属性"></a>8. 动画相关属性</h3><h5 id="过渡动画"><a href="#过渡动画" class="headerlink" title="过渡动画"></a>过渡动画</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transition-property（过渡的属性的名称）。</span><br><span class="line">transition-duration（定义过渡效果花费的时间,默认是 0）。</span><br><span class="line">transition-timing-function:linear(匀速) ease(慢速开始，然后变快，然后慢速结束)（规定过渡效果的时间曲线，最常用的是这两个）。</span><br><span class="line">transition-delay</span><br></pre></td></tr></table></figure>

<h5 id="关键帧动画-通过这个对一个动画的过程的每一部分的表现都做出要求。"><a href="#关键帧动画-通过这个对一个动画的过程的每一部分的表现都做出要求。" class="headerlink" title="关键帧动画:通过这个对一个动画的过程的每一部分的表现都做出要求。"></a>关键帧动画:通过这个对一个动画的过程的每一部分的表现都做出要求。</h5><p>一个关键帧动画，最少包含两部分，animation 属性及属性值（动画的名称和运行方式运行时间等）。@keyframes（规定动画的具体实现过程）<br>animation 属性可以拆分为（当然，我们一般都写一起）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">animation-name 规定@keyframes 动画的名称。</span><br><span class="line">animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0。</span><br><span class="line">animation-timing-function 规定动画的速度曲线。默认是 “ease”，常用的还有linear，同transtion 。</span><br><span class="line">animation-delay 规定动画何时开始。默认是 0。</span><br><span class="line">animation-iteration-count 规定动画被播放的次数。默认是 1，但我们一般用infinite，一直播放。</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>移动端适配方案（必考）</li>
<li>移动端适配1px的问题</li>
</ol>
<h3 id="11-line-height属性1-5和150-区别"><a href="#11-line-height属性1-5和150-区别" class="headerlink" title="11. line-height属性1.5和150%区别"></a>11. line-height属性1.5和150%区别</h3><p><img src="../images/line-height.png" alt><br>其实区别就在于继承的问题上</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=<span class="string">"line-height:150%;font-size:16px;background-colo:yellow;margin:0;"</span>&gt;</span><br><span class="line"> &lt;span&gt;第一行&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp"> &lt;p style="margin:0;font-size:36px;"&gt;第二行&lt;/</span>p&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>150%是先计算后继承，根据父元素的字体大小计算出行高，并且子元素依然沿用这个计算后的行高，此时的第一行的行高是：16px*150%=24px，而第二行的行高是继承父元素的值，所以行高为24px。可以看到如果子元素的字体大小大于父元素，就会出现错位等问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=<span class="string">"line-height:1.5;font-size:16px;background-colo:yellow;margin:0;"</span>&gt;</span><br><span class="line"> &lt;span&gt;第一行&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp"> &lt;p style="margin:0;font-size:36px;"&gt;第二行&lt;/</span>p&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>设置不带单位的，那它就是个“缩放因子”，后代元素会继承这个缩放因子进行计算，而不是继承父元素计算后的值继承，1.5则是先继承后计算（无单位参数），根据子元素自己字体的大小去乘以1.5来计算行高 ： 这时的第一行行高为：16px<em>1.5=24px，而第二行的行高先继承了缩放因子再进行计算，行高为：36px</em>1.5=54px</p>
<h3 id="12-em和rem的区别"><a href="#12-em和rem的区别" class="headerlink" title="12. em和rem的区别"></a>12. em和rem的区别</h3><p><code>em</code>是相对于父元素，而<code>rem</code>是相对于根元素，<code>rem</code>定义是根元素的<code>font-size</code>，以<code>rem</code>为单位，其数值与<code>px</code>的关系，需相对于根元素<code>&lt;html&gt;</code>的<code>font-size</code>计算，比如设置根元素<code>font-size=16px</code>，则表示<code>1rem=16px</code>；</p>
<h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><p>重中之重，没啥可说的刷题就完事了，而且像节流防抖、bind、promise之类的都要会手写。这里就不标必考了，因为大部分都是重点。</p>
<ol>
<li>判断数组方法</li>
<li>Object.assign和Object.create相关</li>
<li>深拷贝和浅拷贝</li>
<li>let、const和var的区别</li>
<li>基本类型和引用类型相关（堆栈）</li>
<li>bind, call, apply相关（自己要会实现）</li>
<li>介绍事件循环（宏任务微任务，要知道执行顺序）</li>
<li>定时器为什么不准（有可能会让你实现一个倒计时）</li>
<li>原型介绍</li>
<li>继承方法（手写）</li>
</ol>
<h3 id="11-闭包介绍和它的作用（手写）"><a href="#11-闭包介绍和它的作用（手写）" class="headerlink" title="11. 闭包介绍和它的作用（手写）"></a>11. 闭包介绍和它的作用（手写）</h3><p>作用：闭包可以让临时变量在外部函数生命周期结束时，仍然存在于内存之中！</p>
<h3 id="12-new实现过程"><a href="#12-new实现过程" class="headerlink" title="12. new实现过程"></a>12. new实现过程</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Fn:当前要new的类Dog</span></span><br><span class="line"><span class="comment">//arg:后期需要给构造函数传递的参数信息['三毛']</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">Fn,...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    obj.__proto__ = Fn.prototype;<span class="comment">//let obj = object.create(Fn.prototype)</span></span><br><span class="line">    Fn.call(obj,...args);</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> sanmao = _new Dog(Dog,<span class="string">'三毛'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">像普通函数执行一样，形成一个私有的作用域+形参赋值+变量提升</span><br><span class="line">默认创建一个对象</span><br><span class="line">链接到原型</span><br><span class="line">让函数中的this指向这个对象，这个对象就是当前类的一个实例</span><br><span class="line">默认把创建的对象返回</span><br></pre></td></tr></table></figure>

<h3 id="13-防抖和节流（手写）"><a href="#13-防抖和节流（手写）" class="headerlink" title="13. 防抖和节流（手写）"></a>13. 防抖和节流（手写）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防抖定义:对于短时间内连续触发的事件（上面的滚动事件）,防抖的含义就是让某个时间期限（如上面的1000毫秒）内,事件处理函数只执行一次。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* fn [function] 需要防抖的函数</span></span><br><span class="line"><span class="comment">* delay [number] 毫秒，防抖期限值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">            clearTimeout(timer)</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(fn,delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ctx;</span><br><span class="line">    <span class="keyword">let</span> args;</span><br><span class="line">    <span class="keyword">let</span> previous = <span class="built_in">Date</span>.now();  <span class="comment">//记录上次触发时间</span></span><br><span class="line">    <span class="keyword">let</span> laterFn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        fn.apply(ctx,args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        ctx = <span class="keyword">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">if</span>(now - previous &gt;= delay)&#123;   <span class="comment">//本次触发时间和上次触发时间比较，如果间隔时间超过设定时间，则再次设置触发的定时器</span></span><br><span class="line">            previous = now;</span><br><span class="line">            setTimeout(laterFn,delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="14">
<li>数组去重、扁平化、柯里化</li>
<li>this指向</li>
<li>es6特性</li>
<li>promise介绍（最好会写）</li>
<li>promise.all和promise.race介绍（手写）</li>
<li>async介绍（了解原理 generator+自执行器）</li>
<li>异步的串行（可以用promise也可以async）</li>
<li>箭头函数指向</li>
</ol>
<h3 id="22-set、map介绍；和数组、对象的区别"><a href="#22-set、map介绍；和数组、对象的区别" class="headerlink" title="22. set、map介绍；和数组、对象的区别"></a>22. set、map介绍；和数组、对象的区别</h3><h4 id="set基本用法"><a href="#set基本用法" class="headerlink" title="set基本用法"></a>set基本用法</h4><p><code>ES6</code> 提供了新的数据结构 <code>Set</code>。它类似于数组，但是成员的值都是唯一的，没有重复的值。<br><code>Set</code>本身是一个构造函数，用来生成 <code>Set</code> 数据结构。<br>向 <code>Set</code> 加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值。<code>Set</code> 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是向 <code>Set</code> 加入值时认为NaN等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</p>
<h4 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h4><p><code>Set</code> 结构的实例有以下属性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set.prototype.constructor：构造函数，默认就是Set函数。</span><br><span class="line">Set.prototype.size：返回Set实例的成员总数。</span><br></pre></td></tr></table></figure>

<h4 id="Set-实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。"><a href="#Set-实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。" class="headerlink" title="Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。"></a>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set.prototype.add(value)：添加某个值，返回 `Set` 结构本身。</span><br><span class="line">Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</span><br><span class="line">Set.prototype.has(value)：返回一个布尔值，表示该值是否为`Set`的成员。</span><br><span class="line">Set.prototype.clear()：清除所有成员，没有返回值。</span><br></pre></td></tr></table></figure>

<h4 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h4><p><code>Set</code> 结构的实例有四个遍历方法，可以用于遍历成员。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set.prototype.keys()：返回键名的遍历器</span><br><span class="line">Set.prototype.values()：返回键值的遍历器</span><br><span class="line">Set.prototype.entries()：返回键值对的遍历器</span><br><span class="line">Set.prototype.forEach()：使用回调函数遍历每个成员</span><br></pre></td></tr></table></figure>

<h3 id="Map含义和基本用法"><a href="#Map含义和基本用法" class="headerlink" title="Map含义和基本用法"></a>Map含义和基本用法</h3><p><code>ES6</code> 提供了 <code>Map</code> 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，<code>Object</code> 结构提供了“字符串—值”的对应，<code>Map</code> 结构提供了“值—值”的对应，是一种更完善的 <code>Hash</code> 结构实现。如果你需要“键值对”的数据结构，<code>Map</code> 比 <code>Object</code>更合适。</p>
<h4 id="Map实例的属性和操作方法"><a href="#Map实例的属性和操作方法" class="headerlink" title="Map实例的属性和操作方法"></a>Map实例的属性和操作方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">size 属性</span><br><span class="line">Map.prototype.set(key, value)</span><br><span class="line">Map.prototype.get(key)</span><br><span class="line">Map.prototype.has(key)</span><br><span class="line">Map.prototype.delete(key)</span><br><span class="line">Map.prototype.clear()</span><br></pre></td></tr></table></figure>

<h4 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h4><p><code>Map</code> 结构原生提供三个遍历器生成函数和一个遍历方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map.prototype.keys()：返回键名的遍历器。</span><br><span class="line">Map.prototype.values()：返回键值的遍历器。</span><br><span class="line">Map.prototype.entries()：返回所有成员的遍历器。</span><br><span class="line">Map.prototype.forEach()：遍历 Map 的所有成员。</span><br></pre></td></tr></table></figure>

<h3 id="23-模块化介绍-commnjs-amd-cmd-umd-export"><a href="#23-模块化介绍-commnjs-amd-cmd-umd-export" class="headerlink" title="23. 模块化介绍(commnjs amd cmd umd export)"></a>23. 模块化介绍(commnjs amd cmd umd export)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">目前模块化的解决方案</span><br><span class="line">CommonJS -- Node.js</span><br><span class="line">AMD -- RequireJS</span><br><span class="line">CMD -- SeaJS</span><br><span class="line">UMD</span><br><span class="line">ES6 Module</span><br></pre></td></tr></table></figure>

<ol start="24">
<li>localstorage sessionstorage cookie</li>
<li>事件委托</li>
</ol>
<h3 id="26-Proxy和Object-defineProperty"><a href="#26-Proxy和Object-defineProperty" class="headerlink" title="26. Proxy和Object.defineProperty"></a>26. Proxy和Object.defineProperty</h3><h4 id="使用Object-defineProperty"><a href="#使用Object-defineProperty" class="headerlink" title="使用Object.defineProperty"></a>使用Object.defineProperty</h4><p><code>ES5</code> 提供了 <code>Object.defineProperty</code> 方法，该方法可以在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(obj, prop, descriptor)</span><br><span class="line">参数：</span><br><span class="line">obj: 要在其上定义属性的对象。</span><br><span class="line">prop: 要定义或修改的属性的名称。</span><br><span class="line">descriptor: 将被定义或修改的属性的描述符。</span><br></pre></td></tr></table></figure>

<p>当然一般不会只是改变一个属性,如下所示，遍历劫持对象所有的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要劫持的对象</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">    name:<span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//遍历对象,对其属性值进行劫持</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data,key,&#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span>: function() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'get'</span>);</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="keyword">set</span>: function(newVal) &#123;</span><br><span class="line">            <span class="comment">// 当属性值发生变化时我们可以进行额外操作</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`我修改了成了<span class="subst">$&#123;newVal&#125;</span>`</span>);           </span><br><span class="line">          &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  data.name = <span class="string">'王莉娜'</span></span><br></pre></td></tr></table></figure>

<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p><code>Object.defineProperty</code>的第一个缺陷,无法监听数组变化</p>
<h5 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h5><ol>
<li><code>Proxy</code>可以直接监听对象而非属性</li>
<li><code>Proxy</code>直接可以劫持整个对象,并返回一个新对象,不管是操作便利程度还是底层功能上都远强于<code>Object.defineProperty</code>。</li>
<li><code>Proxy</code>可以直接监听数组的变化</li>
<li><code>Proxy</code>有多达13种拦截方法,不限于<code>apply、ownKeys、deleteProperty、has</code>等等，这些是<code>Object.defineProperty</code>不具备的。</li>
</ol>
<ol start="27">
<li>下面的输出结果是NaN，3</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	a++;</span><br><span class="line">	<span class="built_in">console</span>.log(a)</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(a)</span><br><span class="line">	&#125;</span><br><span class="line">	inner()</span><br><span class="line">&#125;</span><br><span class="line">outer()</span><br></pre></td></tr></table></figure>

<h2 id="React-native"><a href="#React-native" class="headerlink" title="React native"></a>React native</h2><h5 id="ScrollView-FlatList的适用场景及区别。FlatList相对于ListView做了哪些优化？"><a href="#ScrollView-FlatList的适用场景及区别。FlatList相对于ListView做了哪些优化？" class="headerlink" title="ScrollView,FlatList的适用场景及区别。FlatList相对于ListView做了哪些优化？"></a>ScrollView,FlatList的适用场景及区别。FlatList相对于ListView做了哪些优化？</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ScrollView：渲染数据量少</span><br><span class="line">FlatList：数据量多的</span><br><span class="line">ListView：数据量过大的情况会卡顿（row是持续添加不销毁，导致内存占用大）</span><br><span class="line">FlatList：看不见的元素用空白代替，节省内存渲染快。缺点：滑动太快会有白屏</span><br></pre></td></tr></table></figure>

<h2 id="hybrid"><a href="#hybrid" class="headerlink" title="hybrid"></a>hybrid</h2><h5 id="移动端点击事件为什么会有延迟？有哪些方法可以解决？"><a href="#移动端点击事件为什么会有延迟？有哪些方法可以解决？" class="headerlink" title="移动端点击事件为什么会有延迟？有哪些方法可以解决？"></a>移动端点击事件为什么会有延迟？有哪些方法可以解决？</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原因：等待300ms看用户是点击还是双击缩放</span><br><span class="line">解决方法：禁止缩放，设置默认视口宽度为设备宽度设置css touch-action:none</span><br><span class="line">fastclick.js</span><br></pre></td></tr></table></figure>

<h2 id="jsBridge通信原理"><a href="#jsBridge通信原理" class="headerlink" title="jsBridge通信原理"></a>jsBridge通信原理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JavaScript调用native的方式，主要有两种：注入API和拦截URL scheme</span><br><span class="line">注入API方式的主要原理是：通过webview提供的接口，向JavaScript的Context（Window）中注入对象或者方法</span><br><span class="line">，让JavaScript调用时，直接执行相应的Native代码逻辑，达到JavaScript调用Native的目的。</span><br><span class="line">URL scheme是一种类似url的链接，是为了方便app直接互相调用设计的，形式和普通的url类似，主要区别是</span><br><span class="line">protocol和host一般是自定义的，例如：qunarhy://hy/url?url=ymfe.tech，protocol是qunarhy，host是hy。</span><br><span class="line">拦截URL scheme的主要流程是：web端通过某种方式(iframe.src)发送URL Scheme请求，之后Native拦截到请求并根据URL Scheme（包括所带的参数）进行相关操作</span><br><span class="line">Native调用JavaScript，其实就是执行拼接JavaScript字符串，从外部调用JavaScript中的方法，因此JavaScript的方法</span><br><span class="line">必须在全局的Window上。</span><br></pre></td></tr></table></figure>

<h2 id="算法、数据结构部分"><a href="#算法、数据结构部分" class="headerlink" title="算法、数据结构部分"></a>算法、数据结构部分</h2><p>本来以为只有头条、猿辅导之类的公司才考算法，但是最后发现每家公司都会考，可能都想拿算法来做下区分度了吧。不过遇到做不出来的面试官基本也都会给提示，提示完能写出来也没问题。总体来说考的都是常见的题或者变形而来的，把LeetCode或剑指offer里常见的easy题看了就行。数据结构和设计模式问的很少，但是自己也需要总结了解下。</p>
<ol>
<li>冒泡排序</li>
<li>快速排序</li>
<li>回文字符串</li>
<li>两数之和、k sum</li>
<li>大数相加</li>
<li>二分查找</li>
<li>二叉树前中后遍历</li>
<li>二叉树层次遍历</li>
<li>二叉树深度优先遍历(递归、非递归)</li>
<li>二叉树广度优先遍历(递归、非递归)</li>
<li>和为n的二叉树路径</li>
<li>二叉树深度</li>
<li>二叉树是否对称</li>
<li>链表反转</li>
<li>16进制转10进制</li>
</ol>
<h2 id="项目部分"><a href="#项目部分" class="headerlink" title="项目部分"></a>项目部分</h2><p>每个公司都会有项目的介绍，如果你介绍的项目面试官有兴趣的话会很加分，所以一定要认真准备。我一般会介绍之前做的一个前端微服务的架构，项目做了很多优化也比较复杂，感觉算是自己比较加分的部分。</p>
<ol>
<li><p>介绍下你项目的难点（房型吸顶）</p>
</li>
<li><p>如果现在再看这个项目你会做哪些优化</p>
</li>
<li><p>根据项目的具体问题</p>
</li>
<li><p>我们项目怎么打包发布部署的？<br>通过webpack打包，发布到node服务器，pm2监控及负载均衡。<br>PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g pm2</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态资源怎么发布的<br>a. 简单来说就是文件上传，在不同的区域访问不同的cdn服务器（有cdn中间商来做的，类似七牛云，我们只负责上传就好），<br>b. 版本控制，目前我们是在请求后面加V=xxxxx或者文件生成的时候使用不同的后缀（类似hash）一些静态资源是日期,也有部分hash；目前也是采用日期的形式<br>eg:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;link</span><br><span class="line">        key=<span class="string">"tourplan"</span></span><br><span class="line">        rel=<span class="string">"stylesheet"</span></span><br><span class="line">        type=<span class="string">"text/css"</span></span><br><span class="line">        href=&#123;res.locals.publicPath + <span class="string">'/idiytour/css/tourplan.css?v='</span> + res.locals.version&#125;</span><br><span class="line">/&gt;,</span><br><span class="line">&lt;link</span><br><span class="line">    key=<span class="string">"h5_koala"</span></span><br><span class="line">    rel=<span class="string">"stylesheet"</span></span><br><span class="line">    type=<span class="string">"text/css"</span></span><br><span class="line">    href=&#123;res.locals.publicPath + <span class="string">'/idiytour/css/h5_koala.css?v='</span> + res.locals.version&#125;</span><br><span class="line">/&gt;,</span><br><span class="line">&lt;link</span><br><span class="line">    key=<span class="string">"dp_n"</span></span><br><span class="line">    rel=<span class="string">"stylesheet"</span></span><br><span class="line">    type=<span class="string">"text/css"</span></span><br><span class="line">    href=&#123;res.locals.publicPath + <span class="string">'/idiytour/css/dp_new.css?v='</span> + res.locals.version&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>做了哪些性能优化？<br>。。。</p>
</li>
<li><p>rn用了什么脚手架？底层是什么原理？<br>react-native-cli<br>讲jsx映射成native组件</p>
</li>
<li><p>rn中样式为啥不直接写个object却需要写成stylesheet（{}）这种形式<br>Instead of creating a new style object every time, StyleSheet helps to create style objects with an ID which is further used to reference instead rendering it again.<br>Moving code outside the render() helps in achieving the better understanding of code and adds meaning to low-level components.<br>The stylesheet is sent only once over the bridge unlike normal style object inside render().</p>
</li>
<li><p>怎么和服务端通信的，加密怎么加密的？<br>采用公钥密码体制RSA算法对数据加密</p>
</li>
<li><p>怎么回滚代码的？<br>git log -&gt; reset head -&gt; git push -f</p>
</li>
<li><p>你们jest-converage怎么跑到100%的，这个很难，你们怎么做到的？<br>通过代码覆盖率的检查，分析代码的合理性。删除冗余判断及逻辑，直到覆盖率达到100%</p>
</li>
<li><p>grahql你们后端怎么用的<br>目前后端不使用, 只要针对BFF来做graphql</p>
</li>
<li><p><a href="https://blog.csdn.net/u014209205/article/details/89892359" target="_blank" rel="noopener">cdn基本工作过程</a></p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://acmwln.github.io.com/2020/03/15/jsClientCommunication/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="遗忘的一隅">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="娜一隅">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/15/jsClientCommunication/" itemprop="url">Hybrid和Javascript之间的秘密</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T17:51:03+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>此章节主要讲解<code>Hybrid</code>和<code>Javascript</code>之间的秘密</p>
<h2 id="hrbrid是什么-为何用hybrid"><a href="#hrbrid是什么-为何用hybrid" class="headerlink" title="hrbrid是什么?为何用hybrid?"></a>hrbrid是什么?为何用hybrid?</h2><h4 id="1-hybrid文字解释"><a href="#1-hybrid文字解释" class="headerlink" title="1. hybrid文字解释"></a>1. hybrid文字解释</h4><ul>
<li><code>hybrid</code>即’混合’,即前端和客户端的混合开发</li>
<li>需前端开发人员和客户端开发人员配合完成</li>
<li>某些环节也可能涉及到<code>server</code>端</li>
<li>ps.不要以为自己是前端就可以不理会客户端的知识</li>
</ul>
<h4 id="2-存在价值-为何用hybrid"><a href="#2-存在价值-为何用hybrid" class="headerlink" title="2. 存在价值,为何用hybrid"></a>2. 存在价值,为何用hybrid</h4><ul>
<li>可以快速迭代更新(无需<code>app</code>审核,无需高权限)</li>
<li>体验流畅(和<code>native</code>的体验基本类似)</li>
<li>减少开发和沟通成本,双端公用一套代码</li>
</ul>
<h4 id="3-webview"><a href="#3-webview" class="headerlink" title="3. webview"></a>3. webview</h4><ul>
<li>它是<code>app</code>中的一个组件(<code>app</code>可以有<code>webview</code>,也可以没有)</li>
<li>用于加载<code>h5</code>页面,即一个小型的浏览器内核</li>
</ul>
<h5 id="补充：常见的浏览器内核如下："><a href="#补充：常见的浏览器内核如下：" class="headerlink" title="补充：常见的浏览器内核如下："></a>补充：常见的浏览器内核如下：</h5><ol>
<li><code>Chrome,Safari: webkit</code></li>
<li><code>Firefox:Gecko</code></li>
<li><code>IE: Trident</code></li>
<li><code>360</code>,搜狗等国内浏览器：<code>Trident+webkit</code></li>
</ol>
<h4 id="4-file协议"><a href="#4-file协议" class="headerlink" title="4. file协议"></a>4. file协议</h4><p>【其实在一开始我们就接触<code>html</code>开发,就已经使用了<code>file</code>协议,只不过当时没有’协议’,’标准’等这些概念,这里再次强调’协议’,’标准’的重要性！！！】</p>
<h5 id="file协议和http-s-的区别"><a href="#file协议和http-s-的区别" class="headerlink" title="file协议和http(s)的区别:"></a>file协议和http(s)的区别:</h5><ol>
<li><code>file</code>协议是本地文件,快(断网也可以,打开本地文件即可);<br>表示： <code>&quot;file://&quot;</code> + 文件绝对路径</li>
<li><code>http(s)</code>协议是网络加载,慢(断网不可以);<br>表示：<code>&quot;http(s)://&quot;</code></li>
</ol>
<h4 id="5-hybrid实现流程"><a href="#5-hybrid实现流程" class="headerlink" title="5. hybrid实现流程"></a>5. hybrid实现流程</h4><ul>
<li>不是所有场景都适合使用<code>hybrid</code></li>
<li>使用<code>native</code>:体验要求极致,变化不频繁(如头条的首页)</li>
<li>使用<code>hybrid</code>:体验要求高,变化频繁(如头条的新闻详情页)</li>
<li>使用<code>h5</code>:体验无要求,不常用(如举报,反馈等页面)</li>
</ul>
<h2 id="具体实现如下"><a href="#具体实现如下" class="headerlink" title="具体实现如下:"></a>具体实现如下:</h2><ol>
<li>前端做好静态页面<code>(html js css)</code>,将文件交给客户端</li>
<li>客户端拿到静态页面,以文件形式存储在<code>app</code>中</li>
<li>客户端在一个<code>webview</code>中(重要！！！)</li>
<li>使用<code>file</code>协议加载静态页面(重要！！！)<br>用如下图表示如下:</li>
</ol>
<p><img src="../images/hy.png" alt></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><ol>
<li><code>hybrid</code>是客户端和前端的混合开发</li>
<li><code>hybrid</code>存在的核心意义在于快速迭代,无需审核</li>
<li><code>hybrid</code>实现流程(如上图),以及<code>webview</code>和<code>file</code>协议</li>
</ol>
<h2 id="介绍一下hybrid更新和上线的流程"><a href="#介绍一下hybrid更新和上线的流程" class="headerlink" title="介绍一下hybrid更新和上线的流程"></a>介绍一下hybrid更新和上线的流程</h2><p>先看下面两张图<br><img src="../images/hyserver.png" alt="avatar"><br><img src="../images/hyclient.png" alt="avatar"></p>
<p>要替换每个客户端的静态文件,只能客户端来做(客户端是我们开发的),客户端去<code>server</code>下载最新的静态文件,我们维护<code>server</code>的静态文件</p>
<h4 id="客户端和server先对比版本-如果一致客户端没必要重新下载-不做无谓的下载"><a href="#客户端和server先对比版本-如果一致客户端没必要重新下载-不做无谓的下载" class="headerlink" title="客户端和server先对比版本,如果一致客户端没必要重新下载(不做无谓的下载)"></a>客户端和server先对比版本,如果一致客户端没必要重新下载(不做无谓的下载)</h4><ul>
<li>分版本,有版本号,如<code>20200227</code>(时间戳)</li>
<li>将静态文件压缩成<code>zip</code>包上传到服务器</li>
<li>客户端每次启动,都去服务端检查版本号</li>
<li>如果服务端版本号大于客户端版本号,就去下载最新的<code>zip</code>包</li>
<li>下载完之后解压包,然后将现有文件覆盖</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结:"></a>总结:</h2><p>要点1.掌握流程图<br>要点2.服务端的版本和<code>zip</code>包维护<br>要点3.更新<code>zip</code>包之前先对比版本号<br>要点4.<code>zip</code>包下载解压和覆盖</p>
<h2 id="hybrid和h5的主要区别"><a href="#hybrid和h5的主要区别" class="headerlink" title="hybrid和h5的主要区别"></a>hybrid和h5的主要区别</h2><h4 id="1-优点"><a href="#1-优点" class="headerlink" title="1.优点:"></a>1.优点:</h4><ul>
<li>体验更好,跟<code>native</code>体验基本一致</li>
<li>可快速迭代,无需审核(关键)</li>
</ul>
<h4 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2.缺点:"></a>2.缺点:</h4><ul>
<li>开发成本高,联调,测试,查<code>bug</code>都比较麻烦</li>
<li>运维成本高,可参考此前讲过的更新上线的流程</li>
</ul>
<h4 id="3-适用的场景"><a href="#3-适用的场景" class="headerlink" title="3.适用的场景:"></a>3.适用的场景:</h4><ul>
<li><code>hybrid</code>: 产品的稳定功能,体验要求高,频繁迭代</li>
<li><code>h5</code>: 单次的运营活动(如xx红包)或不常用功能</li>
</ul>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结:"></a>总结:</h2><ul>
<li>优点: 体验好,可快速迭代</li>
<li>缺点: 开发成本高,运维成本高</li>
<li>适用的场景: <code>hybrid</code>适合产品型,<code>h5</code>适合运营型</li>
</ul>
<h2 id="前端js和客户端如何通讯？"><a href="#前端js和客户端如何通讯？" class="headerlink" title="前端js和客户端如何通讯？"></a>前端js和客户端如何通讯？</h2><h3 id="1-js和客户端通讯的基本技术"><a href="#1-js和客户端通讯的基本技术" class="headerlink" title="1. js和客户端通讯的基本技术"></a>1. js和客户端通讯的基本技术</h3><h4 id="js和客户端通讯的基本形式-见下图"><a href="#js和客户端通讯的基本形式-见下图" class="headerlink" title="js和客户端通讯的基本形式(见下图)"></a>js和客户端通讯的基本形式(见下图)</h4><p> <img src="../images/hycommunite.png" alt="avatar"></p>
<ul>
<li><code>js</code>访问客户端能力,传递参数和回调函数</li>
<li>客户端通过回调函数返回内容</li>
</ul>
<h3 id="2-遗留问题-新闻详情页适用hybrid-file协议-前端如何获取到新闻内容？"><a href="#2-遗留问题-新闻详情页适用hybrid-file协议-前端如何获取到新闻内容？" class="headerlink" title="2.遗留问题:新闻详情页适用hybrid(file协议),前端如何获取到新闻内容？"></a>2.遗留问题:新闻详情页适用hybrid(file协议),前端如何获取到新闻内容？</h3><ol>
<li>不能用<code>ajax</code>获取(<code>http</code>协议):第一跨域,第二速度慢。</li>
<li>客户端获取新闻内容后然后通过<code>js</code>通讯拿到内容,再渲染。</li>
</ol>
<h4 id="schema协议简介和适用"><a href="#schema协议简介和适用" class="headerlink" title="schema协议简介和适用"></a>schema协议简介和适用</h4><p><code>schema</code>协议：前端和客户端的约定<br>eg：<br>微信<code>schema</code>格式：<code>&quot;weixin://&quot;</code><br><code>QQ schema</code>协议格式：<code>&quot;QQ://&quot;</code></p>
<h4 id="schema使用的封装"><a href="#schema使用的封装" class="headerlink" title="schema使用的封装"></a>schema使用的封装</h4><h4 id="简单版"><a href="#简单版" class="headerlink" title="简单版"></a>简单版</h4> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</span><br><span class="line"> iframe.style.display = <span class="string">'none'</span></span><br><span class="line"> <span class="comment">//iframe访问schema（重要！！！）</span></span><br><span class="line"> iframe.src = <span class="string">'weixin://dl/scan?k1=v1&amp;k2=v2&amp;k3=v3&amp;callback=_weixin_scan_callback'</span>    </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> body = <span class="built_in">document</span>.body || <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>]</span><br><span class="line"> body.appendchild(iframe)</span><br><span class="line"> setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     body.removeChild(iframe)  <span class="comment">//销毁iframe</span></span><br><span class="line">     iframe = <span class="literal">null</span></span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果要加上参数和callback，那么就必须要这么写</span></span><br><span class="line"> <span class="built_in">window</span>[<span class="string">'_weixin_scan_callback'</span>] = <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">     alert(alert)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="封装版"><a href="#封装版" class="headerlink" title="封装版"></a>封装版</h4> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> <span class="built_in">window</span>.invoke.share(&#123;<span class="attr">title</span>:<span class="string">'xxx'</span>,<span class="attr">content</span>:<span class="string">'xxx'</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(result.errno === <span class="number">0</span>) &#123;</span><br><span class="line">         alert(<span class="string">'分享成功！'</span>)</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         alert(<span class="string">'分享失败！'</span>,result.message)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"><span class="comment">//分享</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">invokeShare</span>(<span class="params">data,callback</span>)</span>&#123;</span><br><span class="line">     _invoke(<span class="string">'share'</span>,data,callback)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//登录</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">invokeLogin</span>(<span class="params">data,callback</span>)</span>&#123;</span><br><span class="line">    _invoke(<span class="string">'login'</span>,data,callback)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//扫一扫</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">invokeScan</span>(<span class="params">data,callback</span>)</span>&#123;</span><br><span class="line">     _invoke(<span class="string">'scan'</span>,data,callback)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//暴露给全局</span></span><br><span class="line"> <span class="built_in">window</span>.invoke = &#123;</span><br><span class="line">     share:invokeShare,</span><br><span class="line">     login:invokeLogin,</span><br><span class="line">     scan:invokeScan</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">_invoke</span>(<span class="params">action,data,callback</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">var</span> schema = <span class="string">'myapp://utils'</span></span><br><span class="line">     schema += <span class="string">'/'</span> + action</span><br><span class="line">     schema += <span class="string">'?a=a'</span></span><br><span class="line">     <span class="keyword">var</span> key</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> data)&#123;     <span class="comment">//data=&#123;title:'xxx',content:'xxx'&#125;</span></span><br><span class="line">         <span class="keyword">if</span>(data.hasOwnProperty(key))&#123;</span><br><span class="line">             schema += <span class="string">'&amp;'</span> + key + <span class="string">'='</span> + data[key]</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//处理callback</span></span><br><span class="line"> <span class="keyword">var</span> callbackName = <span class="string">''</span></span><br><span class="line"> <span class="keyword">if</span>(<span class="keyword">typeof</span> callback === <span class="string">'string'</span>)&#123;</span><br><span class="line">     callbackName = callback</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     callbackName = action + <span class="built_in">Date</span>.now()</span><br><span class="line">     <span class="built_in">window</span>[callbackName] = callback</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> schema += <span class="string">'&amp;callback='</span>+ callbackName</span><br><span class="line"> <span class="comment">//iframe调用schema</span></span><br><span class="line"> 此处省略N行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> (<span class="function"><span class="keyword">function</span>(<span class="params">window,undefined</span>)</span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">_invoke</span>(<span class="params">action,data,callback</span>)</span>&#123;</span><br><span class="line">         <span class="comment">//拼接schema的封装</span></span><br><span class="line">         <span class="keyword">var</span> schema = <span class="string">'myapp://utils'</span> + action</span><br><span class="line">         schema += <span class="string">'?a=a'</span> <span class="comment">//拼接参数</span></span><br><span class="line">         <span class="built_in">window</span>.invoke = &#123;</span><br><span class="line">             share:<span class="function"><span class="keyword">function</span>(<span class="params">data,callback</span>)</span>&#123;</span><br><span class="line">                 _invoke(<span class="string">'share'</span>,data,callback)</span><br><span class="line">             &#125;,</span><br><span class="line">             scan:<span class="function"><span class="keyword">function</span>(<span class="params">data,callback</span>)</span>&#123;</span><br><span class="line">                 _invoke(<span class="string">'scan'</span>,data,callback)</span><br><span class="line">             &#125;,</span><br><span class="line">             login:<span class="function"><span class="keyword">function</span>(<span class="params">data,callback</span>)</span>&#123;</span><br><span class="line">                 _invoke(<span class="string">'login'</span>,data,callback)</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="内置上线"><a href="#内置上线" class="headerlink" title="内置上线"></a>内置上线</h4><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><ol>
<li>通讯的基本形式： 调用能力，传递参数，监听回调</li>
<li>对<code>schema</code>协议的理解和使用</li>
<li>调用<code>schema</code>代码的封装</li>
<li>内置上线的好处：更快，更安全</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://acmwln.github.io.com/2020/03/15/helloBlog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="遗忘的一隅">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="娜一隅">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/15/helloBlog/" itemprop="url">Hello Blog</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T17:51:03+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/随笔/" itemprop="url" rel="index">
                    <span itemprop="name">随笔</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直想有一个属于自己的博客，专门记录平时遇到的一些难题，或者记录些自己对于某些知识点的理解，算是一个记忆吧。由于本人又懒又菜，思考之下决定通过写博客的方式来提供持续学习的动力，积累更多的知识点，顺便在平时遇到的难题中的解决方案进行二次思考，反思，总结。</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"helloBlog"</span></span><br></pre></td></tr></table></figure>

<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://acmwln.github.io.com/2020/03/10/frameDiff/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="遗忘的一隅">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="娜一隅">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/10/frameDiff/" itemprop="url">框架/类库的比较</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-10T15:35:03+08:00">
                2020-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>你使用过哪些前端框架/类库，其各有什么优缺点？</p>
<h3 id="1-React"><a href="#1-React" class="headerlink" title="1. React"></a>1. React</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>速度快：通过在vdom的操作实现真实dom的局部更新</li>
<li>跨浏览器兼容</li>
<li>模块化</li>
<li>单向数据流</li>
<li>同构,接近原生的js</li>
<li>和打包工具配合使用兼容性好</li>
</ol>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>React本身知识一个v而已，并不是一个完整的框架，如果大型项目中如果需要一套完整的框架的话需要搭配react-router使用。</p>
<h3 id="2-Vue"><a href="#2-Vue" class="headerlink" title="2. Vue"></a>2. Vue</h3><p>是一个构建数据驱动的web界面的渐进式MVVM框架</p>
<h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>性能好</li>
<li>简单易用</li>
<li>前后端分离</li>
<li>单页面应用用户体验好</li>
<li>组件化</li>
<li>MVVM</li>
</ol>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>不适于seo优化，而且封装的比较厉害，报错不明显，适合单人开发，适合中小型项目</li>
<li>导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）。</li>
<li>初次加载时耗时多。</li>
<li>页面复杂度提高很多。</li>
</ol>
<h3 id="3-Angular"><a href="#3-Angular" class="headerlink" title="3. Angular"></a>3. Angular</h3><h4 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>模块功能强大丰富，自带了极其丰富的angular指令</li>
<li>是一个比较完善的前端框架，包含服务，模版，数据双向绑定，模块化，路由等。。。</li>
<li>可以自定义指令，可以在项目中多次使用</li>
</ol>
<h4 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>入门很容易，深入学习后概念很多，较难理解</li>
<li>对IE6/7兼容性不好</li>
<li>很灵活，指令应用最佳实践教程少</li>
</ol>
<h3 id="4-Jquery"><a href="#4-Jquery" class="headerlink" title="4. Jquery"></a>4. Jquery</h3><h4 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>代码简洁</li>
<li>脚本与页面分离</li>
<li>丰富的插件开发</li>
<li>性能支持好</li>
<li>节约学习成本</li>
<li>是各大厂商使用类库的标准</li>
</ol>
<h4 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>不能向后兼容，不能兼容早期版本，早期的插件不可用</li>
<li>同一个页面不能使用多个插件，会有冲突</li>
<li>版本更新较快，不稳定</li>
</ol>
<h3 id="5-Nodejs"><a href="#5-Nodejs" class="headerlink" title="5. Nodejs"></a>5. Nodejs</h3><h4 id="优点：-4"><a href="#优点：-4" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>高并发</li>
<li>适合I/O密集型应用</li>
</ol>
<h4 id="缺点：-4"><a href="#缺点：-4" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>不适合CPU密集型应用</li>
<li>只支持单核CPU</li>
<li>可靠性低，一旦代码某个环节崩溃，整个系统都崩溃</li>
<li>更新快</li>
<li>Debug不方便，错误没有stack trace</li>
</ol>
<h3 id="6-Express"><a href="#6-Express" class="headerlink" title="6. Express"></a>6. Express</h3><h4 id="优点：-5"><a href="#优点：-5" class="headerlink" title="优点："></a>优点：</h4><p> 历史悠久，文档资料多并且完整，容易学习</p>
<h4 id="缺点：-5"><a href="#缺点：-5" class="headerlink" title="缺点："></a>缺点：</h4><p>callback比较多</p>
<h3 id="7-lodash"><a href="#7-lodash" class="headerlink" title="7. lodash"></a>7. lodash</h3><h4 id="优点：-6"><a href="#优点：-6" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>内部封装了很多字符串，数组，对象等常见数据类型的处理函数</li>
<li>不是在原有数据上进行操作，而是复制出一份新的数据而不改变原有数据</li>
</ol>
<h4 id="缺点：-6"><a href="#缺点：-6" class="headerlink" title="缺点："></a>缺点：</h4><p>使用lodash库偏离了原生js的写法</p>
<p>8.9.。。。。。后续继续补充。。。</p>
<h2 id="React和Vue的区别与共同点"><a href="#React和Vue的区别与共同点" class="headerlink" title="React和Vue的区别与共同点"></a>React和Vue的区别与共同点</h2><h4 id="共同点"><a href="#共同点" class="headerlink" title="共同点:"></a>共同点:</h4><ol>
<li>都支持组件化</li>
<li>都是数据驱动视图</li>
</ol>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><h5 id="本质区别"><a href="#本质区别" class="headerlink" title="本质区别:"></a>本质区别:</h5><ol>
<li>Vue本质是MVVM框架，由MVC发展而来</li>
<li>React本质上是前端组件化框架，由后端组件化发展而来</li>
</ol>
<h5 id="模版区别"><a href="#模版区别" class="headerlink" title="模版区别:"></a>模版区别:</h5><ol>
<li>Vue使用模版(最初由Angular提出)</li>
<li>React使用JSX</li>
<li>模版语法上，更加倾向于JSX</li>
<li>模版分离上，更加倾向于Vue</li>
</ol>
<h5 id="组件化区别"><a href="#组件化区别" class="headerlink" title="组件化区别:"></a>组件化区别:</h5><ol>
<li>React本身就是组件化，没有组件化就不是React</li>
<li>Vue也支持组件化，不过是在MVVM上的扩展</li>
<li>查阅Vue组件化的文档有很多（侧面反应）</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>国内使用，首推Vue，文档更易读，易学，社区够大</li>
<li>如果团队水平较高，推荐使用React，组件化和JSX</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://acmwln.github.io.com/2020/03/10/reactNativeStyle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="遗忘的一隅">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="娜一隅">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/10/reactNativeStyle/" itemprop="url">CRN布局样式中的一些小分享</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-10T14:54:07+08:00">
                2020-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React-Native/" itemprop="url" rel="index">
                    <span itemprop="name">React Native</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><p>关于<code>&lt;textInput&gt;</code>输入框： <code>TextInput</code>在安卓上默认有一个底边黑线框，同时会有一些<code>padding</code>。如果要想使其看起来和<code>iOS</code>上尽量一致，则需要设置<code>padding: 0</code>，同时设置<code>underlineColorAndroid=&quot;transparent&quot;</code>来去掉底边框。加上<code>padding: 0</code>保证不同机型上下垂直居中。</p>
</li>
<li><p>关于省略号： crn中是通过<code>ellipsizeMode=&#39;tail&#39; numberOfLines={1}</code>两个属性同时控制省略号…（注：这两个属性需要写在<code>&lt;Text&gt;</code>上，不能写在<code>style</code>里。）</p>
</li>
<li><p><code>borderRadius</code>不能和实现三角形样式一起使用，否则不生效；单独写<code>borderBottomLeftRadius</code>和<code>borderBottomRightRadius、borderTopLeftRadius、borderTopRightRadius</code>也不会生效。</p>
</li>
<li><p>实现文本垂直居中的时候尽量不要使用行高，因为行高会在不同平台和机型上面表现的形式不一样，为了保险起见，根据主轴方向使用<code>justifyContent: ‘center’</code>就可以啦!</p>
</li>
<li><p>一般设计稿的尺寸是<code>iphone6</code>的尺寸<code>750px</code>的，我们需要做个适配：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; width, height &#125; = Dimensions.get(<span class="string">'window'</span>);</span><br><span class="line"><span class="keyword">let</span> WIDTH = width, HEIGHT = height;</span><br><span class="line"><span class="keyword">const</span> rem = <span class="function">(<span class="params">a</span>) =&gt;</span> &#123; <span class="keyword">return</span> a * (WIDTH / <span class="number">750</span>); &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关于<code>&lt;Text&gt;</code>： <code>Text</code>元素会继承<code>View</code>层的<code>background</code>: 可以给<code>Text</code>设置<code>backgroundColor:&#39;transparent&#39;</code>解决</p>
</li>
<li><p><code>crn</code>中的<code>width</code>和<code>height</code>是包含<code>padding</code>和<code>border</code>的。</p>
</li>
<li><p>关于<code>Image</code>：可以做背景图展示，它有几个属性方法：<br><code>Source：{uri:string}</code> 进行标记图片的引用，该参数可以为一个网络url地址或者一个本地的路径<br>resizeMode：缩放比例，可选参数<code>(&#39;cover&#39;, &#39;contain&#39;, &#39;stretch&#39;)</code> 该当图片的尺寸超过布局的尺寸的时候，会根据设置<code>Mode</code>进行缩放或者裁剪图片，eg：<code>resizeMode: Image.resizeMode.cover</code></p>
</li>
<li><p>关于雪碧图<code>&lt;SpriteImage&gt;</code>： 雪碧图需要去根据crop裁剪图片，所以会导致在不同机型或者平台中有拉伸缩小情况。以后建议尽量不适用雪碧图。如果需要使用雪碧图也有解决方案: 通过判断机型的dpr来加载图片，安卓的dpr比较散，有1、1.5、2、3、4的，ios的dpr有2、3的。所以需要@3图和@2倍图来做下兼容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;SpriteImage style=&#123;styles.spritePic&#125;</span><br><span class="line">source=&#123;&#123; <span class="attr">uri</span>: PixelRatio.get() === <span class="number">3</span> ? <span class="string">'https://pic.c-ctrip.com/VacationH5Pic/taocan/sdp/n_banner/un_banner@3.png'</span> : <span class="string">'https://pic.c-ctrip.com/VacationH5Pic/taocan/sdp/n_banner/un_banner.png'</span>, <span class="attr">imageSize</span>: &#123; <span class="attr">width</span>: <span class="number">169</span>, <span class="attr">height</span>: <span class="number">167</span> &#125;, crop &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">&lt;<span class="regexp">/SpriteImage&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于小屏手机例如<code>320</code>的，可以通过<code>width === 320</code> 来进行小屏手机的一些兼容</p>
</li>
<li><p>针对<code>1px</code>的<code>border</code>线: <code>border: 1 / PixelRatio.get()</code></p>
</li>
<li><p>关于<code>&lt;TouchableOpacity&gt;</code>：添加点击事件的标签，展示效果会有透明度的变化可以使用<code>activeOpacity={1}</code>去除透明度的变化，<code>&lt;View&gt;</code>外层套此标签的时候style样式尽量写在<code>&lt;View&gt;</code>里，之前做的时候发现写在<br><code>&lt;TouchableOpacity&gt;</code>这个里面出现问题。</p>
</li>
<li><p><code>crn</code>中的分辨率适配： <code>react native</code>中使用的尺寸单位是<code>pt</code>,是一个绝对长度，设计稿使用的是<code>px</code>，这两种尺寸换算可以通过<code>PixelRatio</code>转换。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;PixelRatio&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"><span class="keyword">const</span> pt2px = <span class="function"><span class="params">pt</span>=&gt;</span>PixelRatio.getPixelSizeForLayoutSize(pt);</span><br><span class="line"><span class="keyword">const</span> px2pt = <span class="function"><span class="params">px</span>=&gt;</span>PixelRatio.roundToNearestPixel(px);</span><br></pre></td></tr></table></figure>
</li>
<li><p>梯形+圆角</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Text, View, StyleSheet &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">          &lt;View style = &#123;[styles.btn_one,&#123;<span class="attr">backgroundColor</span>: <span class="string">'#fff'</span>&#125;]&#125;&gt;</span><br><span class="line">            &lt;Text style = &#123;styles.textblock&#125;&gt;高铁+地铁&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">            &lt;View style = &#123;styles.cateory&#125;&gt;&lt;/</span>View&gt;</span><br><span class="line">          &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">          &lt;View style = &#123;styles.btn_one&#125;&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Text style = &#123;styles.textblock&#125;&gt;高铁&lt;/</span>Text&gt;</span><br><span class="line">          &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">           &lt;View style = &#123;styles.btn_one&#125;&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Text style = &#123;styles.textblock&#125;&gt;地铁&lt;/</span>Text&gt;</span><br><span class="line">          &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> styles = StyleSheet.create(&#123;</span><br><span class="line">  container: &#123;</span><br><span class="line">    backgroundColor: <span class="string">'#53b8fb'</span>,</span><br><span class="line">    height: <span class="number">100</span>,</span><br><span class="line">    flexDirection: <span class="string">"row"</span>,</span><br><span class="line">    borderTopLeftRadius: <span class="number">7</span>,</span><br><span class="line">    borderTopRightRadius: <span class="number">7</span>,</span><br><span class="line">    marginTop: <span class="number">100</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  btn_one: &#123;</span><br><span class="line">    flex: <span class="number">1</span>,</span><br><span class="line">    borderRadius: <span class="number">10</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">cateory: &#123;</span><br><span class="line"> height:<span class="number">0</span>,</span><br><span class="line"> width:<span class="number">0</span>,</span><br><span class="line"> borderBottomWidth: <span class="number">100</span>,</span><br><span class="line"> borderLeftWidth: <span class="number">50</span>,</span><br><span class="line"> borderRightWidth: <span class="number">50</span>,</span><br><span class="line"> borderStyle: <span class="string">'solid'</span>,</span><br><span class="line"> borderBottomColor: <span class="string">'#f00'</span>,</span><br><span class="line"> borderLeftColor: <span class="string">'transparent'</span>,</span><br><span class="line"> borderRightColor: <span class="string">'transparent'</span>,</span><br><span class="line"> marginRight: <span class="number">10</span>,</span><br><span class="line"> transform: [&#123;<span class="attr">skewX</span>: <span class="string">'45deg'</span>&#125;,&#123;<span class="attr">rotateX</span>:<span class="string">'180deg'</span>&#125;,&#123;<span class="attr">rotateY</span>:<span class="string">'180deg'</span>&#125;],</span><br><span class="line"> position: <span class="string">'absolute'</span>,</span><br><span class="line"> bottom: <span class="number">0</span>,</span><br><span class="line"> left: <span class="number">0</span>,</span><br><span class="line"> &#125;,</span><br><span class="line">textblock: &#123;</span><br><span class="line">    color: <span class="string">'#fff'</span>,</span><br><span class="line">    fontSize: <span class="number">14</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://acmwln.github.io.com/2020/03/10/reactNative/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="遗忘的一隅">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="娜一隅">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/10/reactNative/" itemprop="url">CRN踩坑记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-10T14:06:52+08:00">
                2020-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React-Native/" itemprop="url" rel="index">
                    <span itemprop="name">React Native</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="非技术方面"><a href="#非技术方面" class="headerlink" title="非技术方面"></a>非技术方面</h2><h3 id="遇到的坑："><a href="#遇到的坑：" class="headerlink" title="遇到的坑："></a>遇到的坑：</h3><pre><code>1.    需求问题，由于多数需求与以前保持一致也没有出新的需求文档，就直接扒了h5的逻辑，提测后就哭了:sob:
2.    对CRN现有功能不熟悉，例：右上角消息盒子，到开发阶段后期才发现 公共不支持此功能</code></pre><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><pre><code>1.    测试让咋改就咋改了。。。以后做之前一定要明确需求，不能自己YY，即使是扒逻辑也要和相关人员进行确认
2.    和框架沟通支持相关功能。做之前熟悉下相关API，对不确定是否能做到的东西要尽早提出。</code></pre><h2 id="技术方面"><a href="#技术方面" class="headerlink" title="技术方面"></a>技术方面</h2><h3 id="一-功能"><a href="#一-功能" class="headerlink" title="一. 功能"></a>一. 功能</h3><p>熟悉RN及CRN的API后基本没什么大问题</p>
<h3 id="二-性能"><a href="#二-性能" class="headerlink" title="二. 性能"></a>二. 性能</h3><h4 id="页面切换"><a href="#页面切换" class="headerlink" title="页面切换"></a>页面切换</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        showInit: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">    InteractionManager.runAfterInteractions(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            showInit: <span class="literal">false</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">render() &#123;</span><br><span class="line">    &#123;<span class="keyword">this</span>.state.showInit ?</span><br><span class="line">    &lt;View&gt;&lt;LoadingView style=&#123;&#123; flex: 1 &#125;&#125; /&gt;&lt;/View&gt;:</span><br><span class="line">    &lt;ViewPort&gt;</span><br><span class="line">        &lt;HeaderView page=&#123;<span class="keyword">this</span>&#125; title=&#123;<span class="string">'选择日期'</span>&#125; /&gt;</span><br><span class="line">        &lt;View&gt;巴拉巴拉&lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>ViewPort&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; dir = <span class="string">'flight'</span>, type,index,curCity = &#123;&#125; &#125; = <span class="keyword">this</span>.props</span><br><span class="line">    InteractionManager.runAfterInteractions(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.props.events.reqCityList(&#123;</span><br><span class="line">            dir,</span><br><span class="line">            type,</span><br><span class="line">            index,</span><br><span class="line">            curCity</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>耗时较长的工作安排到所有互动或动画完成之后再进行 <code>RN InteractionManager</code><br>tip:注意<code>dispatch</code>用的点，<code>dispatch</code>会改变组件的<code>state</code></p>
<h4 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h4><h5 id="1-ScrollView"><a href="#1-ScrollView" class="headerlink" title="1. ScrollView"></a>1. <code>ScrollView</code></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">子元素一次性渲染 </span><br><span class="line">scrollTo(&#123; x: 0, animated: <span class="literal">true</span> &#125;)  animated为<span class="literal">true</span>时对x方向定义点问题  </span><br><span class="line">tip：安卓上scrollTo方法需要添加setTimeout才生效。。。</span><br></pre></td></tr></table></figure>

<h5 id="2-ListView"><a href="#2-ListView" class="headerlink" title="2. ListView"></a>2. <code>ListView</code></h5><p>可惰性渲染，超出页面的不会回收，数据量大的时候，内存损耗大<br>eg：城市选择页，有右边索引条，快速滑动。<br>坑：数据量大，直接滚动到最下面的时候，<code>ios</code>为白屏，安卓只能滚到当前渲染到的地方。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">1. onContentSizeChange</span><br><span class="line">监控当前渲染的位置，没有到要滚到点的位置，自动触发scrollTo再次滚</span><br><span class="line">2. scrollRenderAheadDistance</span><br><span class="line">当一个行接近屏幕范围多少像素之内的时候，就开始渲染这一行。</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListView</span><br><span class="line">    ref=&#123;listView =&gt; <span class="keyword">this</span>._listView = listView&#125;</span><br><span class="line">    dataSource=&#123;<span class="keyword">this</span>.state.dataSource&#125;</span><br><span class="line">    onContentSizeChange=&#123;<span class="keyword">this</span>.onContentSizeChange.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line">    renderRow=&#123;<span class="keyword">this</span>.renderRow.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line">    renderSectionHeader=&#123;<span class="keyword">this</span>.renderSectionHeader&#125;</span><br><span class="line">    initialListSize=&#123;<span class="number">20</span>&#125;<span class="comment">//组件刚挂载的时候渲染多少行数据</span></span><br><span class="line">    scrollRenderAheadDistance=&#123;<span class="keyword">this</span>.state.height&#125;</span><br><span class="line">    pageSize=&#123;<span class="number">100</span>&#125; <span class="comment">//每次事件循环（每帧）渲染的行数</span></span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure>

<h5 id="3-CRNListView"><a href="#3-CRNListView" class="headerlink" title="3. CRNListView"></a>3. <code>CRNListView</code></h5><p>基于<code>ListView</code><br>有一些自定义的功能，下拉刷新、加载更多、侧边栏等<br>但是侧边栏支持ios不支持安卓。。。:triumph:<br><code>SectionList FlatList</code><br>官方为解决<code>listview</code>性能问题重新推出的<code>list</code><br>有回收机制（不再屏幕内的内容会被回收）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;FlatList</span><br><span class="line">    initialNumToRender=&#123;<span class="number">6</span>&#125;<span class="comment">//如方法名，这部分不会在滚动过程中被卸载</span></span><br><span class="line">    maxToRenderPerBatch=&#123;<span class="number">6</span>&#125;</span><br><span class="line">    getItemLayout=&#123;<span class="keyword">this</span>.getItemLayout&#125;<span class="comment">//可选的优化 对于我们的场景（有scrollTo）必需</span></span><br><span class="line">    horizontal=&#123;<span class="keyword">this</span>.props.horizontal&#125;</span><br><span class="line">    keyExtractor=&#123;(item)=&gt;item.showMonth&#125;</span><br><span class="line">    ref=&#123;flatList =&gt; <span class="keyword">this</span>._flatList = flatList&#125;</span><br><span class="line">    data=&#123;<span class="keyword">this</span>.state.monthInfo&#125;</span><br><span class="line">    renderItem=&#123;<span class="keyword">this</span>.getMonthView.bind(<span class="keyword">this</span>)&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p>属性 <code>initialScrollIndex</code><br>    小坑：设置了这个属性<code>（getItemLayout(data, index)</code>这个<code>index</code>会返回-1）<br>方法 <code>scrollToIndex scrollToOffset</code></p>
<h4 id="代码写法"><a href="#代码写法" class="headerlink" title="代码写法"></a>代码写法</h4><ul>
<li>减少<code>View</code>层的嵌套，<code>cpu</code>优化</li>
<li>避免不必要的循环，尤其是在页面渲染的时候（反面例子 日历页计算今天明天后天的时候）</li>
<li>健壮性 慎用<code>a.b.c.d</code>写法；<code>async await</code> 这种写法不同与<code>promise</code>的<code>then catch</code>，需要用<code>try catch</code>捕获异常；</li>
<li>可读性</li>
<li>可维护性</li>
</ul>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul>
<li><code>console</code> 会影响性能</li>
<li><code>debugger</code>页面要单拉出来</li>
</ul>
<h3 id="三-样式"><a href="#三-样式" class="headerlink" title="三. 样式"></a>三. 样式</h3><ul>
<li>遵循标准UI稿或者<code>CSS</code>稿</li>
<li>尽量少使用特殊判断或者计算，能用<code>flex</code>解决的要用<code>flex</code>解决</li>
<li>有意识的考虑到不同屏幕手机</li>
<li>慎用 <code>Sprite Image</code>，会增大不必要的内存消耗。</li>
</ul>
<h3 id="四-兼容性"><a href="#四-兼容性" class="headerlink" title="四. 兼容性"></a>四. 兼容性</h3><ul>
<li>样式的兼容</li>
<li>注意<code>API</code>上 <code>android ios</code>的不同点</li>
</ul>
<h3 id="五-其他"><a href="#五-其他" class="headerlink" title="五. 其他"></a>五. 其他</h3><ul>
<li>调试 <code>debugger console.log</code></li>
<li>性能调试 <code>console.time</code></li>
</ul>
<h2 id="git提交事项"><a href="#git提交事项" class="headerlink" title="git提交事项"></a>git提交事项</h2><ul>
<li>提测后 慎提交<code>mock</code>数据</li>
<li>尽量用<code>rebase</code></li>
<li>切记不要影响别人的项目代码</li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>会深入学习会在性能及用户体验上多下功夫，发挥<code>RN</code>的优势</p>
<blockquote>
<p>对自己的代码负责。<br>没有解决不了的bug。如果有，一定是没有找到方法。<br>没有填不平的坑。如果有，一定要尽力填平。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://acmwln.github.io.com/2020/03/04/crossDomain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="遗忘的一隅">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="娜一隅">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/04/crossDomain/" itemprop="url">9种跨域解决方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-04T11:25:55+08:00">
                2020-03-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>跨域，相信大家无论是在工作中还是在面试中经常遇到这个问题，常常在网上看到别人所整理的一些方法，看似知道是怎么回事，但如果没有动手实践过，总觉得自己没有真正的掌握，在这里，通过自己认真思考整理一些常用的方法。</p>
<h2 id="跨域的产生"><a href="#跨域的产生" class="headerlink" title="跨域的产生"></a>跨域的产生</h2><p>相信大家都知道跨域是因为浏览器的同源策略所导致的。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。浏览器引入同源策略主要是为了防止XSS，CSRF攻击。</p>
<blockquote>
<p>CSRF（Cross-site request forgery），跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。</p>
</blockquote>
<h2 id="跨域的解决方案"><a href="#跨域的解决方案" class="headerlink" title="跨域的解决方案"></a>跨域的解决方案</h2><h3 id="1-通过jsonp跨域"><a href="#1-通过jsonp跨域" class="headerlink" title="1.通过jsonp跨域"></a>1.通过jsonp跨域</h3><p>首先说一下jsonp的原理，例如我们平时写html的时候常常会使用<br><code>&lt;script src=&quot;www.b.com/js/jquery.js&quot;&gt;&lt;/script&gt;</code>这种方式去取放在另外服务器上的静态资源，这个是不受同源策略所限制的，所以我们利用这一点可以解决跨域的问题。</p>
<h4 id="原生实现"><a href="#原生实现" class="headerlink" title="原生实现"></a>原生实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在www.a.com域名写下如下代码，去请求www.b.com域名的数据</span></span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.creatElement(<span class="string">'script'</span>);</span><br><span class="line">script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">script.src = <span class="string">'http://www.b.com/getdata?callback=demo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们利用动态脚本的src属性，变相地发送了一个<code>http://www.b.com/getdata?callback=demo</code>,这时候，<code>b.com</code>页面接受到这个请求时，如果没有JSONP,会正常返回<code>json</code>的数据结果，像这样：<code>{ msg: &#39;helloworld&#39; }</code>,而利用<code>JSONP</code>,服务端会接受这个<code>callback</code>参数，然后用这个参数值包装要返回的数据：<code>demo({msg: &#39;helloworld&#39;})</code>;</p>
<p>这时候，如果a.com的页面上正好有一个<code>demo</code> 的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当远程数据一返回的时候，随着动态脚本的执行，这个<code>demo</code>函数就会被执行。</p>
<h4 id="jquery-ajax请求实现"><a href="#jquery-ajax请求实现" class="headerlink" title="jquery ajax请求实现"></a>jquery ajax请求实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:<span class="string">'http:127.0.0.1:8001/list'</span>,</span><br><span class="line">    method:<span class="string">'get'</span>,</span><br><span class="line">    dataType:<span class="string">'jsonp'</span>, <span class="comment">// 请求方式为jsonp</span></span><br><span class="line">    success:<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务器serverJsonp.js</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line">app = express()</span><br><span class="line">app.listen(<span class="number">8001</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ok!'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="string">'list'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;&#125; = req.query</span><br><span class="line">    <span class="keyword">let</span> data = &#123;</span><br><span class="line">        data:<span class="number">0</span>,</span><br><span class="line">        message:<span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">    res.send(<span class="string">'$&#123;callback&#125;($&#123;JSON.stringify(data)&#125;)'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-CORS跨域资源共享"><a href="#2-CORS跨域资源共享" class="headerlink" title="2.CORS跨域资源共享"></a>2.CORS跨域资源共享</h3><p>所有浏览器都支持该功能，IE浏览器不能低于<code>IE10</code>。</p>
<h4 id="2-1-简单请求和非简单请求"><a href="#2-1-简单请求和非简单请求" class="headerlink" title="2.1 简单请求和非简单请求"></a>2.1 简单请求和非简单请求</h4><p>浏览器将<code>CORS</code>请求分成两类：简单请求<code>（simple request）</code>和非简单请求<code>（not-so-simple request)</code>.</p>
<h5 id="简单请求同时满足以下条件-只要不满足以下条件的则为非简单请求"><a href="#简单请求同时满足以下条件-只要不满足以下条件的则为非简单请求" class="headerlink" title="简单请求同时满足以下条件,只要不满足以下条件的则为非简单请求"></a>简单请求同时满足以下条件,只要不满足以下条件的则为非简单请求</h5><p><img src="../images/post01.png" alt></p>
<h4 id="2-2-进行带有身份凭证的CORS请求"><a href="#2-2-进行带有身份凭证的CORS请求" class="headerlink" title="2.2 进行带有身份凭证的CORS请求"></a>2.2 进行带有身份凭证的CORS请求</h4><ul>
<li>默认情况下的跨域请求都是不会把<code>cookie</code>发送给服务器的，在需要发送的情况下，如果是<code>xhr</code>，那么需要设置<code>xhr.withCredentials=true</code></li>
<li>如果是采用fetch获取的话，那么需要在<code>request</code>里面设置 <code>credentials:&#39;include&#39;</code></li>
<li>但是如果服务器在预请求的时候没返回<code>Access-Control-Allow-Crenditials:true</code>的话，那么在实际请求的时候，cookie是不会被发送给服务器端的，要特别注意对于简单的get请求，不会有预请求的过程</li>
<li>那么在实际请求的时候，如果服务器没有返回<code>Access-Control-Allow-Crenditials:true</code>的话那么响应结果浏览器也不会交给请求者<br>对于附带身份凭证的请求，服务器不得设置 <code>Access-Control-Allow-Origin</code> 的值为“<em>”。<br>这是因为请求的首部中携带了 <code>Cookie</code> 信息，如果 <code>Access-Control-Allow-Origin</code><br>的值为“</em>”，请求将会失败。而将 <code>Access-Control-Allow-Origin</code> 的值设置为<br><code>http://www.a.com</code>，则请求将成功执行。</li>
</ul>
<h4 id="2-3-HTTP响应首部字段"><a href="#2-3-HTTP响应首部字段" class="headerlink" title="2.3 HTTP响应首部字段"></a>2.3 HTTP响应首部字段</h4><ul>
<li><code>Access-Control-Allow-Origin</code>: <origin> | *</origin></li>
<li><code>Access-Control-Expose-Headers</code> 头让服务器把允许浏览器访问的头放入白名单</li>
<li><code>Access-Control-Max-Age</code> 头指定了preflight请求的结果能够被缓存多久</li>
<li><code>Access-Control-Allow-Credentials</code> 头指定了当浏览器的<code>credentials</code>设置为<code>true</code>时是否允许浏览器读取<code>response</code>的内容</li>
<li><code>Access-Control-Allow-Methods</code> 首部字段用于预检请求的响应。其指明了实际请求所允许使用的<code>HTTP</code>方法。</li>
<li><code>Access-Control-Allow-Headers</code> 首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段。<h4 id="2-2-以nodejs-express为例，说明如何使用cors解决跨域"><a href="#2-2-以nodejs-express为例，说明如何使用cors解决跨域" class="headerlink" title="2.2 以nodejs express为例，说明如何使用cors解决跨域"></a>2.2 以nodejs express为例，说明如何使用cors解决跨域</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line">    <span class="keyword">var</span> express=<span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line">    <span class="keyword">var</span> url=<span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line">    <span class="keyword">var</span> app=express();</span><br><span class="line">    <span class="keyword">var</span> allowCrossDomain = <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//设置哪个源可以访问我</span></span><br><span class="line">        res.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'http://localhost:9001'</span>);</span><br><span class="line">        <span class="comment">//允许哪个方法访问我</span></span><br><span class="line">        res.setHeader(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'GET,PUT,POST,DELETE'</span>);</span><br><span class="line">        <span class="comment">//允许携带哪个头访问我</span></span><br><span class="line">        res.setHeader(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type'</span>);</span><br><span class="line">        <span class="comment">//允许携带cookie</span></span><br><span class="line">        res.setHeader(<span class="string">'Access-Control-Allow-Credentials'</span>,<span class="string">'true'</span>);</span><br><span class="line">        <span class="comment">//预检的存活时间</span></span><br><span class="line">        res.setHeader(<span class="string">'Access-Control-Max-Age'</span>,<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//允许前端获取哪个头</span></span><br><span class="line">        res.setHeader(<span class="string">'Access-Control-Expose-Headers'</span>,<span class="string">'name'</span>);</span><br><span class="line">        next();</span><br><span class="line">    &#125;;</span><br><span class="line">    app.use(allowCrossDomain);</span><br><span class="line">    app.get(<span class="string">'/getData'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">req,res,next</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> queryValue=url.parse(req.url).query;</span><br><span class="line">        <span class="keyword">if</span>(queryValue===<span class="string">'fortunewheel@sina.com'</span>)&#123;</span><br><span class="line">            res.send(<span class="literal">true</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            res.send(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    app.listen(<span class="number">3001</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-http-proxy-（http代理）"><a href="#3-http-proxy-（http代理）" class="headerlink" title="3.http proxy （http代理）"></a>3.http proxy （http代理）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">webpack+webpack-dev-server</span><br><span class="line">devServer:&#123;</span><br><span class="line">    proxy:&#123;</span><br><span class="line">        <span class="string">'/'</span>:&#123;</span><br><span class="line">            target:<span class="string">'http:127.0.0.1'</span>,</span><br><span class="line">            changeOrigin:<span class="literal">true</span>    <span class="comment">//设置此属性走跨域</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-nginx反向代理"><a href="#4-nginx反向代理" class="headerlink" title="4. nginx反向代理"></a>4. nginx反向代理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    <span class="comment">// 监听8080端口</span></span><br><span class="line">    listen <span class="number">8080</span></span><br><span class="line">    <span class="comment">// 域名是localhost</span></span><br><span class="line">    server_name localhost</span><br><span class="line">    <span class="comment">// 凡是localhost:8080/api这个样子的，都转发到真正的服务端的地址http://www.b.com:8080</span></span><br><span class="line">    location ^~ <span class="regexp">/api&#123;</span></span><br><span class="line"><span class="regexp">        proxy_pass  http:/</span><span class="regexp">/www.b.com:8080</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>配置之后就不需要前端做什么修改了，一般我们在前后端分离项目中开发阶段会采用这种方式，但不是所有场景都能这样做，例如后端接口是一个公共的<code>API</code>，比如一些公共服务获取天气什么的。</p>
<h3 id="5-window-postMessage"><a href="#5-window-postMessage" class="headerlink" title="5. window.postMessage"></a>5. window.postMessage</h3><p><code>postMessage</code>是<code>HTML5 XMLHttpRequest Level 2</code>中的<code>API</code>，且是为数不多可以跨域操作的<code>window</code>属性之一，它可用于解决以下方面的问题：</p>
<ul>
<li><code>iframe</code>嵌套页面跨域通信</li>
<li>页面和其打开的新窗口的通信</li>
<li>多窗口之间消息传递</li>
</ul>
<p>用法：<br><code>postMessage(data,origin)</code>方法接受两个参数，</p>
<p>data：需要传递的数据，html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用<code>JSON.stringify()</code>序列化。<br>origin：协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//http://www.a.com/a.html</span></span><br><span class="line">&lt;ifram id=<span class="string">"iframe"</span> src=<span class="string">"http://www.b.com/b.html"</span> style=<span class="string">"display:none"</span>&gt;&lt;/iframe&gt;</span><br><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span><br><span class="line">iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = &#123;</span><br><span class="line">        name:<span class="string">'wanglina'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向http://www.b.com传递跨域数据</span></span><br><span class="line">    iframe.contentWindow.postMessage(<span class="built_in">JSON</span>.stringify(data),<span class="string">'http://www.b.com'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//http://www.b.com/b.html</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;    <span class="comment">//接收http://www.a.com/a.html的数据</span></span><br><span class="line">    alert(<span class="string">'data from http://www.a.com/a.html---&gt; '</span> + ev.data);</span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(ev.data);</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        data.number = <span class="number">16</span>;</span><br><span class="line">        <span class="comment">// 处理后再发回http://www.a.com/a.html</span></span><br><span class="line">        <span class="comment">// window.parent.postMessage(JSON.stringify(data), 'http://www.a.com');</span></span><br><span class="line">        ev.source.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">'http://www.a.com'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h3 id="6-document-domain-iframe"><a href="#6-document-domain-iframe" class="headerlink" title="6. document.domain + iframe"></a>6. document.domain + iframe</h3><p>这种方式只适合主域名相同，但子域名不同的<code>iframe</code>跨域。<br>实现原理：两个页面都通过<code>js</code>强制设置<code>document.domain</code>为基础主域，就实现了同域。<br>使用方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//http://www.a.com/a.html</span></span><br><span class="line">&lt;iframe id=<span class="string">"iframe"</span> src=<span class="string">"http://www.child.a.com/b.html"</span> style=<span class="string">"display:none;"</span>&gt;&lt;/iframe&gt;</span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'a.com'</span>; </span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'hello world'</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//http://www.child.a.com/b.html</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'a.com'</span>; </span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">window</span>.parent.a;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure>

<h3 id="7-window-name-iframe"><a href="#7-window-name-iframe" class="headerlink" title="7. window.name + iframe"></a>7. window.name + iframe</h3><p><code>window.name</code> 传输技术的基本原理：<br>当在浏览器中打开一个页面，或者在页面中添加一个<code>iframe</code>时即会创建一个对应的<code>window</code>对象，当页面加载另一个新的页面时，<code>window.name</code>的属性是不会变的。这样就可以利用在页面动态添加一个<code>iframe</code>然后加载数据页面，在数据页面将需要的数据赋值给<code>window.name</code>。然而此时承载的<code>iframe</code>的<code>parent</code>页面还是不能直接访问不在同一域下的<code>iframe</code>的那么属性，这时，只需要将iframe再加载一个与承载页面同域的空白页面，即可对<code>window.name</code>进行数据读取。<br><code>window.name</code>属性的独特之处：<code>name</code>值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的<code>name</code>值（2MB)<br>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>
<p>具体实现：<br><code>http://www.a.com/a.html</code> 主页面<br><code>http://www.b.com/b.html</code> 数据页面<br><code>http://www.a.com/proxy.html</code> 代理页面</p>
<ul>
<li><p><code>http://www.a.com/a.html</code>代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">crossDomainGetData</span>(<span class="params">url,callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> state = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">    iframe.src = url;</span><br><span class="line">    iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(state === <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> data = iframe.contentWindow.name;<span class="comment">//代理页面成功过后，读取window.name</span></span><br><span class="line">            callback&amp;&amp;callback(data);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//销毁iframe</span></span><br><span class="line">            iframe.contentWindow.document.write(<span class="string">''</span>);</span><br><span class="line">            iframe.contentWindow.close();</span><br><span class="line">            <span class="built_in">document</span>.body.removeChild(iframe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>http://www.b.com/b.html</code>代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">'123'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>http://www.a.com/proxy.html</code>   （中间代理页，与<code>a.html</code>同域，内容为空即可）</p>
</li>
</ul>
<h3 id="8-location-hash-iframe"><a href="#8-location-hash-iframe" class="headerlink" title="8.location.hash + iframe"></a>8.location.hash + iframe</h3><p>实现原理： <code>a</code>欲与<code>b</code>跨域相互通信，通过中间页<code>c</code>来实现。 三个页面，不同域之间利用<code>iframe</code>的<code>location.hash</code>传值，相同域之间直接<code>js</code>访问来通信。</p>
<p>具体实现：A域：<code>a.html</code> -&gt; B域：<code>b.html</code> -&gt; A域：<code>c.html</code>，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p>
<ul>
<li><p><code>a.html：(http://www.domain1.com/a.html)</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;iframe id=<span class="string">"iframe"</span> src=<span class="string">"http://www.domain2.com/b.html"</span> style=<span class="string">"display:none;"</span>&gt;&lt;/iframe&gt;</span><br><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向b.html传hash值</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    iframe.src = iframe.src + <span class="string">'#user=admin'</span>;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开放给同域c.html的回调方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onCallback</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'data from c.html ---&gt; '</span> + res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>b.html：(http://www.domain2.com/b.html)</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;iframe id=<span class="string">"iframe"</span> src=<span class="string">"http://www.domain1.com/c.html"</span> style=<span class="string">"display:none;"</span>&gt;&lt;/iframe&gt;</span><br><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听a.html传来的hash值，再传给c.html</span></span><br><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    iframe.src = iframe.src + location.hash;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>c.html：(http://www.domain1.com/c.html)</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听b.html传来的hash值</span></span><br><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 再通过操作同域a.html的js回调，将结果传回</span></span><br><span class="line">    <span class="built_in">window</span>.parent.parent.onCallback(<span class="string">'hello: '</span> + location.hash.replace(<span class="string">'#user='</span>, <span class="string">''</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="9-websocket协议跨域"><a href="#9-websocket协议跨域" class="headerlink" title="9. websocket协议跨域"></a>9. websocket协议跨域</h3><p><code>websoket</code>协议天然支持跨域，你只需要学会如何使用它即可<a href="https://segmentfault.com/a/1190000017086942" target="_blank" rel="noopener">websocket协议</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://acmwln.github.io.com/2020/03/02/cookeVsSession/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="遗忘的一隅">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="娜一隅">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/02/cookeVsSession/" itemprop="url">浅谈cookie，session和localStorage，sessionStorage的区别及cookie安全方面</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-02T10:47:14+08:00">
                2020-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>浅谈<code>cookie</code>，<code>session</code>和<code>localStorage</code>，<code>sessionStorage</code>的区别，既然是浅谈，就不会详细从底层原理解释这几个的区别，就简单地聊一下，这几个的区别，优缺点，应用场景</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>浏览器的缓存机制提供了可以将用户数据存储在客户端上的方式，可以利用<code>cookie</code>和<code>session</code>跟服务端进行数据交互。<br><code>cookie</code>和<code>session</code>都是用来跟踪浏览器用户身份的会话方式，<code>cookie</code>通过在客户端记录信息确定用户身份；session通过在服务器端记录信息确定用户身份，但是<code>session</code>的实现依赖于<code>cookie</code>。<code>sessionId</code>（<code>session</code>的唯一标识需要存放在客户端）</p>
<h2 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h2><h3 id="1-使用方式"><a href="#1-使用方式" class="headerlink" title="1.使用方式"></a>1.使用方式</h3><h5 id="cookie机制："><a href="#cookie机制：" class="headerlink" title="cookie机制："></a>cookie机制：</h5><ul>
<li>不设置过期时间的<code>cookie</code>，存储在内存中，生命周期在会话期间，关闭浏览器窗口，<code>cookie</code>就消失。称为会话<code>cookie</code></li>
<li>设置了过期时间的cookie，会在硬盘中，关闭了浏览器再次打开还是会读取<code>cookie</code>，只要不超过时间</li>
<li>cookie是服务端发给客户端的特殊信息，<code>cookie</code>是以文本的方式保存在客户端，每次请求时都带上它</li>
</ul>
<h5 id="session机制："><a href="#session机制：" class="headerlink" title="session机制："></a>session机制：</h5><p>当服务器收到请求需要创建<code>session</code>对象时，首先会检查客户端请求中是否包含<code>sessionid</code>。如果有<code>sessionid</code>，服务器将根据该id返回对应<code>session</code>对象。如果客户端请求中没有<code>sessionid</code>，服务器会创建新的<code>session</code>对象，并把<code>sessionid</code>在本次响应中返回给客户端。通常使用cookie方式存储sessionid到客户端，在交互中浏览器按照规则将<code>sessionid</code>发送给服务器。如果用户禁用<code>cookie</code>，则要使用<code>URL</code>重写，可以通过<code>response.encodeURL(url)</code>进行实现；<code>API</code>对<code>encodeURL</code>的解释为，当浏览器支持<code>cookie</code>时，<code>url</code>不做任何处理；当浏览器不支持<code>cookie</code>的时候，将会重写<code>URL</code>将<code>sessionid</code>拼接到访问地址后。</p>
<h3 id="2-保持状态"><a href="#2-保持状态" class="headerlink" title="2.保持状态"></a>2.保持状态</h3><p><code>cookie</code>保存在浏览器端<br><code>session</code>保存在服务器端</p>
<h3 id="3-存储的大小"><a href="#3-存储的大小" class="headerlink" title="3.存储的大小"></a>3.存储的大小</h3><p>单个<code>cookie</code>保存的数据不能超过<code>4kb</code>；很多浏览器都限制一个站点最多保存20个<code>cookie</code>。<br><code>session</code>大小没有限制。</p>
<h3 id="4-存储内容"><a href="#4-存储内容" class="headerlink" title="4.存储内容"></a>4.存储内容</h3><p><code>cookie</code>只能保存字符串类型，以文本的方式。<br><code>session</code>通过类似与<code>Hashtable</code>的数据结构来保存，能支持任何类型的对象（<code>session</code>中可含有多个对象）</p>
<h3 id="5-安全性"><a href="#5-安全性" class="headerlink" title="5.安全性"></a>5.安全性</h3><p><code>session</code>的安全性大于<code>cookie</code>。原因如下：</p>
<ul>
<li><code>sessionid</code>存储在<code>cookie</code>中，若要攻破<code>session</code>首先要攻破<code>cookie</code>；</li>
<li><code>sessionid</code>是要有人登录，或者启动<code>session_start</code>才会有，所以攻破<code>cookie</code>也不一定能得到<code>sessionid</code>；</li>
<li>第二次启动<code>session_start</code>后，前一次的<code>sessionid</code>就是失效了，<code>session</code>过期后，<code>sessionid</code>也随之失效。</li>
<li><code>sessionid</code>是加密的。</li>
<li><code>cookie</code>不是很安全，别人可以分析存放在本地的<code>cookie</code>并进行<code>cookie</code>欺骗，考虑到安全应当使用<code>session</code><br>综上所述，攻击者必须在短时间内攻破加密的<code>sessionid</code>，这很难。</li>
</ul>
<h3 id="6-性能"><a href="#6-性能" class="headerlink" title="6.性能"></a>6.性能</h3><p><code>session</code>会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用<code>cookie</code>。</p>
<h3 id="7-应用场景"><a href="#7-应用场景" class="headerlink" title="7.应用场景"></a>7.应用场景</h3><h5 id="cookie"><a href="#cookie" class="headerlink" title="cookie`:"></a>cookie`:</h5><ul>
<li>判断用户是否登录过网站，以便下次登录时能够实现自动登录（或者记住密码）。</li>
<li>保存上次登录的时间等信息。</li>
<li>保存上次查看的页面</li>
<li>浏览计数</li>
</ul>
<h5 id="session："><a href="#session：" class="headerlink" title="session："></a>session：</h5><ul>
<li>网上商城中的购物车：添加了商品之后客户端处可以知道添加了哪些商品，而服务器端如何判别呢，所以也需要存储一些信息就用到了<code>session</code></li>
<li>保存用户登录信息</li>
<li>将某些数据放入<code>session</code>中，供同一用户的不同页面使用</li>
<li>防止用户非法登录</li>
<li>购物车最好使用<code>cookie</code>，但是<code>cookie</code>是可以在客户端禁用的，这时候我们要使用<code>cookie+</code>数据库的方式实现，当从<code>cookie</code>中不能取出数据时，就从数据库获取。</li>
</ul>
<h3 id="8-缺点"><a href="#8-缺点" class="headerlink" title="8.缺点"></a>8.缺点</h3><h5 id="cookie："><a href="#cookie：" class="headerlink" title="cookie："></a>cookie：</h5><ul>
<li>大小受限</li>
<li>用户可以操作（禁用）cookie，使功能受限</li>
<li>安全性较低</li>
<li>有些状态不可能保存在客户端</li>
<li>每次访问都要传送cookie给服务器，浪费宽带</li>
<li>cookie数据有路径（path）的概念，可以限制cookie只属于某个路径下。</li>
</ul>
<h5 id="session：-1"><a href="#session：-1" class="headerlink" title="session："></a>session：</h5><ul>
<li><code>session</code>保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大</li>
<li>依赖于<code>cookie</code>（<code>sessionid</code>保存在<code>cookie</code>），如果禁用<code>cookie</code>，则要使用URL重写</li>
<li>创建<code>session</code>变量有很大的随意性，可随时调用，不需要开发者做精确地处理，所以过度的使用<code>session</code>变量将会导致代码不可读而且不好维护。</li>
</ul>
<h2 id="cookie和session的相同点"><a href="#cookie和session的相同点" class="headerlink" title="cookie和session的相同点"></a>cookie和session的相同点</h2><ul>
<li><code>session</code>和<code>cookie</code>都是由服务器生成的</li>
<li><code>session</code>和<code>cookie</code>都是键值对，即<code>session</code>和<code>cookie</code>就是用来保存特定的值的一种技术</li>
</ul>
<h2 id="cookie机制-一个cookie的设置以及发送过程分为以下四步-："><a href="#cookie机制-一个cookie的设置以及发送过程分为以下四步-：" class="headerlink" title="cookie机制(一个cookie的设置以及发送过程分为以下四步)："></a>cookie机制(一个cookie的设置以及发送过程分为以下四步)：</h2><ul>
<li>客户端发送一个<code>http</code>请求到服务器端</li>
<li>服务器端发送一个<code>http</code>响应到客户端，其中包含<code>Set-Cookie</code>头部</li>
<li>客户端发送一个<code>http</code>请求到服务器端，其中包含<code>Cookie</code>头部</li>
<li>服务器端发送一个<code>http</code>响应到客户端</li>
</ul>
<h2 id="cookie属性项"><a href="#cookie属性项" class="headerlink" title="cookie属性项"></a>cookie属性项</h2><table width="100%">
   <tr>
      <td>属性项</td>
      <td>属性项介绍</td>
   </tr>
   <tr>
      <td>NAME=VALUE</td>
      <td>键值对，可以设置要保存的 Key/Value，注意这里的 NAME 不能和其他属性项的名字一样</td>
   </tr>
   <tr>
      <td>Expires</td>
      <td>过期时间，在设置的某个时间点后该 Cookie 就会失效</td>
   </tr>
   <tr>
      <td>Domain</td>
      <td>生成该 Cookie 的域名，如 domain="www.baidu.com"</td>
   </tr>
   <tr>
      <td>Path</td>
      <td>该 Cookie 是在当前的哪个路径下生成的，如 path=/wp-admin/</td>
   </tr>
   <tr>
      <td>Secure</td>
      <td>如果设置了这个属性，那么只会在 SSH 连接时才会回传该 Cookie</td>
   </tr>
</table>

<h2 id="设置cookie"><a href="#设置cookie" class="headerlink" title="设置cookie"></a>设置cookie</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">json,time</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime()+time*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>).toUTCString();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> json)&#123;</span><br><span class="line">        <span class="built_in">document</span>.cookie = key+<span class="string">"="</span>+json[key]+<span class="string">";expires="</span>+date</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setCookie(&#123;</span><br><span class="line">    name:<span class="string">'wanglina'</span>,</span><br><span class="line">    sex:<span class="string">'female'</span></span><br><span class="line">&#125;,<span class="number">7</span>);</span><br></pre></td></tr></table></figure>

<h2 id="获取cookie"><a href="#获取cookie" class="headerlink" title="获取cookie"></a>获取cookie</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">attr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.cookie.match(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(^|\\s)"</span>+attr+<span class="string">"=([^;]+)(;|$)"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="清除cookie"><a href="#清除cookie" class="headerlink" title="清除cookie"></a>清除cookie</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeCookie</span>(<span class="params">attr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> json = &#123;&#125;;</span><br><span class="line">    json[attr] = <span class="string">""</span>;</span><br><span class="line">    setCookie(json,<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="javascript如何判断浏览器是否禁用cookie"><a href="#javascript如何判断浏览器是否禁用cookie" class="headerlink" title="javascript如何判断浏览器是否禁用cookie"></a>javascript如何判断浏览器是否禁用cookie</h2><p>语法：<code>navigator.cookieEnabled</code>；<br>如果浏览器启用了<code>cookie</code>，该属性值为<code>true</code>。如果禁用了<code>cookie</code>，则值为<code>false</code>。</p>
<p><code>navigator</code>：<br> <code>JavaScript</code>中的一个独立的对象，他用于提供用户所使用的浏览器以及操作系统等信息，以<code>navigator</code>对象属性的形式来提供。</p>
<h2 id="防止javascript脚本读取cookie信息"><a href="#防止javascript脚本读取cookie信息" class="headerlink" title="防止javascript脚本读取cookie信息"></a>防止javascript脚本读取cookie信息</h2><p>1.设置HttpOnly<br>如果您在cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击。</p>
<p>2.HttpOnly的设置样例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">"Set-Cookie"</span>, <span class="string">"cookiename=value;Path=/;Domain=domainvalue;Max-Age=seconds;HTTPOnly"</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//设置http的cookie</span><br><span class="line">response.setHeader(<span class="string">"Set-Cookie"</span>, <span class="string">"uid=112; Path=/; HttpOnly"</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//设置https的cookie</span><br><span class="line">response.setHeader(<span class="string">"Set-Cookie"</span>, <span class="string">"uid=112; Path=/; Secure; HttpOnly"</span>);</span><br></pre></td></tr></table></figure>



<h2 id="WebStorage"><a href="#WebStorage" class="headerlink" title="WebStorage"></a>WebStorage</h2><p> <code>WebStorage</code>的目的是克服由<code>cookie</code>所带来的一些限制，当数据需要被严格控制在客户端时，不需要持续的将数据发回服务器。</p>
<h4 id="WebStorage两个主要目标："><a href="#WebStorage两个主要目标：" class="headerlink" title="WebStorage两个主要目标："></a>WebStorage两个主要目标：</h4><p>1.提供一种在<code>cookie</code>之外存储会话数据的路径<br>2.提供一种存储大量可以跨会话存在的数据的机制</p>
<p><code>HTML5</code>的<code>WebStorage</code>提供了两种<code>API</code>：<code>localStorage</code>（本地存储）和<code>sessionStorage</code>（会话存储）</p>
<h3 id="localStorage和sessionStorage的区别"><a href="#localStorage和sessionStorage的区别" class="headerlink" title="localStorage和sessionStorage的区别"></a>localStorage和sessionStorage的区别</h3><h5 id="1-生命周期"><a href="#1-生命周期" class="headerlink" title="1.生命周期"></a>1.生命周期</h5><p><code>localStorage</code>的生命周期是永久的，关闭页面或浏览器之后<code>localStorage</code>中的数据也不会消失。<code>localStorage</code>除非主动删除数据，否则数据永远不会消失。<br><code>sessionStorage</code>的生命周期是仅在当前会话下有效。<code>sessionStorage</code>引入了一个“浏览器窗口”的概念，<code>sessionStorage</code>是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是<code>sessionStorage</code>在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，<code>sessionStorage</code>也是不一样的。</p>
<h5 id="2-存储大小"><a href="#2-存储大小" class="headerlink" title="2.存储大小"></a>2.存储大小</h5><p><code>localStorage</code>和<code>sessionStorage</code>的存储数据大小一般都是：5MB</p>
<h5 id="3-存储位置"><a href="#3-存储位置" class="headerlink" title="3.存储位置"></a>3.存储位置</h5><p><code>localStorage</code>和<code>sessionStorage</code>都保存在客户端，不与服务器进行交互通信</p>
<h5 id="4-存储内容类型"><a href="#4-存储内容类型" class="headerlink" title="4.存储内容类型"></a>4.存储内容类型</h5><p><code>localStorage</code>和<code>sessionStorage</code>只能存储字符串类型，对于复杂的对象可以使用<code>ECMAScript</code>提供的<code>JSON</code>对象的<code>stringify</code>和<code>parse</code>来处理</p>
<h5 id="5-获取方式"><a href="#5-获取方式" class="headerlink" title="5.获取方式"></a>5.获取方式</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localStorage：window.localStorage</span><br><span class="line">sessionStorage：window.sessionStorage</span><br></pre></td></tr></table></figure>

<h5 id="6-应用场景"><a href="#6-应用场景" class="headerlink" title="6.应用场景"></a>6.应用场景</h5><p><code>localStorage</code>：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据<br><code>sessionStorage</code>：敏感账号一次性登录</p>
<h2 id="WebStorage的优点"><a href="#WebStorage的优点" class="headerlink" title="WebStorage的优点"></a>WebStorage的优点</h2><ul>
<li>存储空间更大：<code>cookie</code>为4KB，而<code>WebStorage</code>是5MB</li>
<li>节省网络流量：<code>WebStorage</code>不会传送到服务器，存储在本地的数据可以直接获取，也不会像<code>cookie</code>一样每次请求都会传送到服务器，所以减少了客户端和服务端的交互，节省了网络流量</li>
<li>对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，<code>sessionStorage</code>会非常方便</li>
<li>快速显示：有的数据存储在<code>WebStorage</code>上再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快</li>
<li>安全性：<code>WebStorage</code>不会随着<code>HTTP header</code>发送到服务器端，所以安全性相对于<code>cookie</code>来说会比较高一些，不会担心截获，但是仍然存在伪造问题</li>
<li><code>WebStorage</code>提供了一些方法，数据操作比<code>cookie</code>方便<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setItem(key, value) —— 保存数据，以键值对的方式存储信息</span><br><span class="line">getItem(key) —— 获取数据，将键值传入，即可获取到对应的value值</span><br><span class="line">removeItem(key) —— 删除单个数据，根据键值移除对应的信息</span><br><span class="line">clear() —— 删除所有的数据</span><br><span class="line">key(index) —— 获取某个索引的key</span><br></pre></td></tr></table></figure>

</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpeg" alt="遗忘的一隅">
            
              <p class="site-author-name" itemprop="name">遗忘的一隅</p>
              <p class="site-description motion-element" itemprop="description">千里之行,始于足下</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/acmwln" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">遗忘的一隅</span>

  
</div>



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
